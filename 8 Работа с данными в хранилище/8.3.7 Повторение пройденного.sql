Повторение пройденного
Запросы дооптимизировали, индексы прошли, тема закончилась. Пора переходить к проекту. Но перед этим — повторите изученное.
Что такое оптимизация запросов
Оптимизация запросов — набор действий, направленный на увеличение скорости выполнения запросов, снижение потребляемых ресурсов (CPU, RAM), повышение читаемости кода.
Наибольшее влияние на оптимальность выполнения запроса оказывают:
Специфика данных: тип, объём, структура.
Модель данных: каким образом данные размещены по таблицам.
Применяемая функциональность СУБД: использование встроенных функций, построенные индексы, ограничения.
Компьютерное железо, на котором запущена СУБД.
Как исследовать план запроса
Чтобы понять, можно ли оптимизировать запрос, нужно посмотреть его план. Используйте команду EXPLAIN: её нужно добавлять непосредственно перед запросом, который вы хотите оптимизировать. Синтаксис выглядит так:

EXPLAIN SELECT * FROM my_table;

-- QUERY PLAN                                                          |
-- --------------------------------------------------------------------+
-- Seq Scan on my_table  (cost=0.00..13.43 rows=543 width=28)          | 
Этот запрос не содержит никаких условий, поэтому планировщик выбрал план последовательного сканирования Seq Scan:
cost=0.00..13.43 — примерная оценка стоимости обработки данных без вывода (0.00) и примерная оценка общей стоимости (13.43 — условные единицы или единицы стоимости). Чем меньше стоимость запроса, тем он производительнее.
rows=543 — число строк, которое планировщик ожидает на выводе при исполнении этого этапа запроса.
width=28 — средний размер строк, который ожидает планировщик на выводе при исполнении запроса.
EXPLAIN не выполняет запрос, а только строит его план и оценивает примерную стоимость. Если вы хотите убедиться в точности оценки, то можете воспользоваться командой EXPLAIN ANALYZE. Запрос выполнится фактически, и будет выведена дополнительная информация в плане запроса, например Planning Time и Execution Time.
Nested Loop
Nested Loop — это вложенный цикл, который принимает на вход строки от двух этапов сканирования — Seq Scan и Bitmap Heap Scan. Цикл Nested Loop будет применять каждую строку Seq Scan для каждой строки Bitmap Index Scan и Bitmap Heap Scan, а в качестве результата выдавать обработанную строку.
Hash Join
При Hash Join строки одной из таблиц записываются в структуру данных хеш-таблицы, которая состоит из ключей в виде хешей и значений. 
Merge Join
Merge Join — это соединение слиянием данных нескольких таблиц. Для него нужно, чтобы входные данные были отсортированы по ключам условия соединения. Cуть метода — в сортировке данных по алгоритму слияния и сравнению уже отсортированных данных.
Статистика для таблиц
Чтобы помочь планировщику подобрать более выгодный план, можно заранее посчитать расширенную статистику для таблиц. Сделать это можно с помощью CREATE STATISTICS и ANALYZE. Например, вот так:

CREATE STATISTICS stats (dependencies) ON column_a, colum FROM my_table;

ANALYZE my_table; 
Что такое индексы
Индексы в СУБД — специальные объекты базы данных, предназначенные в основном для ускорения доступа к данным. Это вспомогательные структуры: любой индекс можно удалить и восстановить заново по информации в таблице.
Индексы в СУБД работают по принципу, аналогичному индексу в книге. Они позволяют быстро находить данные, не просматривая все строки таблицы. Индекс содержит ключи, каждый из которых связан с определённой строкой или набором строк.
Как создать индекс
Создать индекс можно следующим образом:

CREATE INDEX имя_индекса ON название_таблицы [USING тип_индекса](название_столбца); 
Команда [USING тип_индекса] здесь указана в квадратных скобках, потому что эта команда необязательна. Если не указать USING с конкретным типом индекса, то будет создан индекс B-tree по умолчанию.
Типы индексов
В зависимости от данных СУБД PostgreSQL поддерживает разные типы индексов или, по-другому, методы доступа. Типы индекса определяют, каким образом будут структурированы и упорядочены индексируемые данные, чтобы доступ к ним был наиболее оптимальным. 
B-tree
Индекс B-tree строит сбалансированное дерево поиска по значениям. Если в запросе используются операторы <, <=, =, >=, >, то индекс B-tree может быть успешно построен и использован при запросе данных.
Hash
Тип индекса Hash использует хеш-функции для создания ключа. Хеш-функция принимает на вход объект любого типа и возвращает соответствующее ему числовое значение в типе INT.
GiST
GiST (сокр. от Generalized Search Tree) — это тоже сбалансированное дерево поиска, но отличается от B-tree тем, что не привязано к семантике больше, меньше или равно. GiST чаще всего используется для следующих данных:
точки и другие геометрические объекты, поиск ближайших соседей выбранной точки;
интервалы и ограничения исключений;
полнотекстовый поиск.
SP-GiST
SP-GiST (сокр. от Space Partitioning Generalized Search Trees) использует дерево поиска, но при этом размещает определённым образом само пространство. SP-GiST подходит для структур, в которых пространство рекурсивно разбивается на непересекающиеся области.
GIN
GIN (сокр. от Generalized Inverted Index) — инвертированный, или обратный, индекс, в котором могут содержаться значения с несколькими ключами, например массивы. 
BRIN
BRIN (сокр. от Block Range Indexes) — индекс интервала блоков. Такой индекс хранит обобщённые сведения о значениях, находящихся в последовательно расположенных блоках таблицы. Поэтому такие индексы наиболее эффективны для столбцов, значения в которых хорошо коррелируют с физическим порядком столбцов таблицы.


