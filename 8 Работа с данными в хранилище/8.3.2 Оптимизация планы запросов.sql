Оптимизация: планы запросов
Не всегда удаётся написать такой запрос, который бы эффективно использовал ресурсы машины. Когда приходится писать большие скрипты для решения задачи, сложно сразу сделать так, чтобы каждая конструкция в коде оптимально работала и скорость выполнения запроса была приемлемой. Поэтому запросы исследуются и улучшаются с точки зрения эффективности. 
Что такое оптимизация запросов
Оптимизация запросов — набор действий, направленный на увеличение скорости выполнения запросов, снижение потребляемых ресурсов (CPU, RAM), повышение читаемости кода. В идеальном случае при оптимизации улучшаются показатели по всем трём перечисленным факторам. Однако чаще всего запросы оптимизируют для достижения только одного показателя. 
Наибольшее влияние на оптимальность выполнения запроса оказывают:
Специфика данных: тип, объём, структура.

Если числовые данные хранятся в символьном представлении, то с ними нельзя проводить математические операции. Чтобы работать с числовыми функциями, нужно преобразовать строковые данные в числа, а это лишние действия при выполнении запроса и трата ресурсов.
Модель данных: каким образом данные размещены по таблицам.

Если модель спроектирована неудачно, то данные можно будет получить, только если объединить результаты запросов из множества несвязанных таблиц. Для этого надо использовать сложные операции группировки, фильтрацию, избавление от дублей. Времени и ресурсов на выполнение такого кода уйдёт больше.
Применяемая функциональность СУБД: использование встроенных функций, построенные индексы, ограничения.
Компьютерное железо, на котором запущена СУБД.
Чтобы начать оптимизировать запросы, для начала нужно узнать план запроса.
Как исследовать план запроса
План запроса — это то, как СУБД исполняет запрос, в какую конструкцию превращает его. Когда вы нажимаете кнопку запуска запроса, СУБД передаёт код для анализа в планировщик запросов. Планировщик анализирует структуру вашего кода — данные, которые находятся в запрашиваемых таблицах, существующие индексы и другие факторы, — а затем строит наиболее оптимальный план выполнения запроса.
Команда EXPLAIN
Чтобы понять, можно ли оптимизировать запрос, нужно посмотреть его план. Используйте команду EXPLAIN: её нужно добавлять непосредственно перед запросом, который вы хотите оптимизировать. Синтаксис выглядит так:

EXPLAIN SELECT * FROM my_table;

-- QUERY PLAN                                                          |
-- --------------------------------------------------------------------+
-- Seq Scan on my_table  (cost=0.00..13.43 rows=543 width=28)          | 
Этот запрос не содержит никаких условий, поэтому планировщик выбрал план последовательного сканирования Seq Scan:
cost=0.00..13.43 — примерная оценка стоимости обработки данных без вывода (0.00) и примерная оценка общей стоимости (13.43 — условные единицы или единицы стоимости). Так как вы просто сканируете данные и дополнительной обработки нет, то планировщик оценил стоимость в 0.00. Если бы в плане была ещё и сортировка, то указывалась бы оценочная стоимость процесса сортировки. Однако данные всё-таки нужно вывести и скооперировать вместе, поэтому примерная оценочная стоимость такого запроса 13.43. Чем меньше стоимость запроса, тем он производительнее.
rows=543 — число строк, которое планировщик ожидает на выводе при исполнении этого этапа запроса.
width=28 — средний размер строк в байтах, который ожидает планировщик на выводе при исполнении запроса.
Один и тот же запрос на одних и тех же данных может показывать разные параметры при оценке стоимости. Это может зависеть от версии СУБД, технических характеристик, компонентов компьютера и от нагрузки на этот компьютер со стороны другого программного обеспечения и планировщика. Поэтому оптимизированные запросы в СУБД на локальной машине могут показывать другие результаты в сравнении с СУБД на серверной машине, где работает основное решение. 
Результаты чаще всего можно аппроксимировать друг на друга: например, если запрос работает в два раза быстрее локально, то примерно на такой же порядок быстрее будет работать на серверной машине.
Пример. Если локально удалось сократить время работы с 10 секунд до 5 секунд, то на серверной машине ожидается сокращение времени работы запроса в 2 раза. В абсолютных значениях это может быть сокращение с 3 секунд до 1.5 секунд. Однако на серверной машине также может существовать и другая нагрузка — постоянный поток запросов, другие приложения и процессы, — что, в свою очередь, может негативно сказаться на производительности даже оптимизированных запросов.
Фильтрация данных
Изменим запрос и добавим туда условие WHERE.

EXPLAIN SELECT * FROM my_table WHERE id < 100;

-- QUERY PLAN                                                             |
-- -----------------------------------------------------------------------+
-- Seq Scan on my_table (cost=0.00..15.54 rows=99 width=28)               |
--   Filter: (id < 100)                                                   | 
К плану запроса добавился ещё один этап Filter — за последовательным сканированием происходит фильтрация данных по условию. Хоть мы и добавили условие id < 100, на первом этапе всё равно будут просканированы все строки таблицы, а затем к результату будет применён фильтр. При этом общая стоимость плана запроса стала больше (15.54), так как некоторое время уйдёт на проверку условия. 
План с двумя этапами исполнения
Напишем условие, при котором выборка будет меньше: сократим диапазон значений.

EXPLAIN SELECT * FROM my_table WHERE id < 10;

-- QUERY PLAN                                                                         |
-- -----------------------------------------------------------------------------------+
-- Bitmap Heap Scan on my_table (cost=1.34..7.61 rows=9 width=28)                     |
--   Recheck Cond: (id < 10)                                                          |
--   ->  Bitmap Index Scan on my_table_id  (cost=0.00..4.34 rows=9 width=0)           |
--         Index Cond: (id < 10)      
План запроса стал совсем другим. Планировщик подобрал несколько планов, сравнил их общую стоимость и выбрал план с двумя этапами исполнения. 
Стрелка -> в плане запроса указывает на то, что сначала будет выполнен этап Bitmap Index Scan. На этом этапе просматривается индекс PRIMARY KEY id для получения ссылок на конкретные строки в хранилище с учётом условия id < 10. Затем полученные ссылки передаются следующему этапу. Верхний этап Bitmap Heap Scan с помощью ссылок получает эти строки из хранилища таблицы. 
Общая стоимость запроса стала значительно меньше.
План для нескольких индексов
Если в таблице есть ещё индексы, например, вторичный ключ, который также используется в условии WHERE, то планировщик может подобрать план, где применяется комбинация этих индексов.

EXPLAIN SELECT * FROM my_table WHERE id < 10 AND second_id > 10000;

-- QUERY PLAN                                                                              |
-- ----------------------------------------------------------------------------------------+
--  Bitmap Heap Scan on my_table  (cost=4.36..17.65 rows=9 width=28)                       |
--    Recheck Cond: ((id < 10) AND (second_id > 10000))                                    |
--    ->  BitmapAnd  (cost=10.08..10.08 rows=9 width=0)                                    |
--          ->  Bitmap Index Scan on my_table_id  (cost=0.00..5.04 rows=9 width=0)         |
--                Index Cond: (id < 10)                                                    |
--          ->  Bitmap Index Scan on my_table_second_id  (cost=0.00..2.78 rows=999 width=0)|
--                Index Cond: (second_id > 10000)                                          | 
Использование индексов в большинстве случаев даёт лучшую производительность, но не всегда. В нашем случае из-за комбинации индексов нужно обойти оба индекса (это может быть дольше, чем обойти один индекс), а для другого условия использовать фильтр. 
Например, если добавить в запрос LIMIT, то план запроса получится таким:

EXPLAIN SELECT * FROM my_table WHERE id < 10 AND second_id > 10000 LIMIT 2;

-- QUERY PLAN                                                              |
-- ------------------------------------------------------------------------+
-- Limit  (cost=0.00..4.32 rows=2 width=28)                                |
--   ->  Seq Scan on my_table  (cost=0.00..19.45 rows=9 width=28)          |
--         Filter: ((id < 10) AND (second_id > 10000))                     | 
Оценочная стоимость плана запроса снизилась, при этом Seq Scan всё равно проходит по всем строкам, так как предполагается, что запрос выполнится полностью. Этап LIMIT завершает запрос, как только удаётся получить указанное количество строк, тем самым снижая общую стоимость запроса. 
EXPLAIN не выполняет запрос, а только строит его план и оценивает примерную стоимость. Если вы хотите убедиться в точности оценки, то можете воспользоваться командой EXPLAIN ANALYZE. Запрос выполнится фактически и будет выведена дополнительная информация в плане запроса, например Planning Time и Execution Time.
Пока мы показали, как оптимизировать простой запрос с условием WHERE и командой LIMIT. А как будет выглядеть более сложный план? 
План сложного запроса
Вот план более сложного запроса — с соединением двух таблиц по выбранным столбцам:

EXPLAIN 
SELECT * 
FROM my_table_1 t1, my_table_2 t2 
WHERE t1.id < 1000000 AND t1.second_id = t2.second_id;

-- QUERY PLAN                                                                         |
-- -----------------------------------------------------------------------------------+
-- Nested Loop  (cost=4.29..24.85 rows=1 width=142)                                   |
--   ->  Seq Scan on my_table_1 t1  (cost=0.00..14.79 rows=1 width=28)                |
--         Filter: (id > 1000000)                                                     |
--   ->  Bitmap Heap Scan on my_table_2 t2  (cost=4.29..10.05 rows=2 width=114)       |
--         Recheck Cond: (second_id = t1.second_id)                                   |
--         ->  Bitmap Index Scan on main4  (cost=0.00..4.29 rows=2 width=0)           |
--               Index Cond: (second_id = t1.second_id)                               | 
В этом плане новое — только последний этап Nested Loop. 
Nested Loop
Nested Loop — это вложенный цикл, который принимает на вход строки от двух этапов сканирования — Seq Scan и Bitmap Heap Scan. Цикл Nested Loop будет применять каждую строку Seq Scan для каждой строки Bitmap Index Scan и Bitmap Heap Scan, а в качестве результата выдавать обработанную строку.
Работу Nested Loop можно визуализировать следующий образом:
Nested Loop интенсивно использует CPU и в худшем случае будет сравнивать каждую строку одной выборки с каждой строкой другой выборки. Обычно Nested Loop используется, когда выборка небольшая. Если же работа происходит с большими объёмами и при этом планировщиком выбирается Nested Loop, обновите статистику по данным с помощью ANALYZE или добавьте индексы по обрабатываемым столбцам. 
В сложных запросах результаты одного из этапов часто нужны для других этапов. В таком случае в плане запроса может присутствовать слово Materialized — это означает, что результат этапа будет сохранён в памяти, чтобы его можно было потом выгодно переиспользовать. Это эффективнее, чем выполнять один тяжёлый этап несколько раз. 
Помимо Nested Loop, существуют ещё Hash Join и Merge Join.
Hash Join
При Hash Join строки одной из таблиц записываются в структуру данных хеш-таблицы, которая состоит из ключей в виде хешей и значений. Хеши получаются в результате работы хеш-функции, которая преобразует любое значение в набор некоторых чисел.
После построения хеш-таблицы сканируется другая таблица, и строки из второй таблицы приводятся в соответствие данным из хеш-таблицы. Иногда использование хеш-таблицы даёт большую выгоду для производительности запроса.
Планировщик использует Hash Join при относительно большой выборке. При малых выборках Hash Join не так эффективен, так как тратится достаточно большое количество времени на построение хеш-таблицы относительно самой выборки. Гораздо проще «пробежаться» по всем строкам и сравнить их друг с другом.
Работу Hash Join можно визуализировать следующим образом:
План с хэш-таблицей может выглядеть так:

EXPLAIN 
SELECT * 
FROM my_table_1 t1, my_table_2 t2 
WHERE t1.id < 10 AND t1.second_id = t2.second_id;

-- QUERY PLAN                                                                    |
-- ------------------------------------------------------------------------------+
-- Hash Join  (cost=14.90..33.49 rows=6 width=142)                               |
--   Hash Cond: (t2.second_id = t1.second_id)                                      |
--   ->  Seq Scan on my_table_2 t2  (cost=0.00..17.63 rows=363 width=114) |
--   ->  Hash  (cost=14.79..14.79 rows=9 width=28)                               |
--         ->  Seq Scan on my_table_1 t1  (cost=0.00..14.79 rows=9 width=28)|
--               Filter: (id < 10) 
Выполните запрос с EXPLAIN ANALYZE и посмотрите дополнительную информацию:

EXPLAIN ANALYZE
SELECT * 
FROM my_table_1 t1, my_table_2 t2 
WHERE t1.id < 10 AND t1.second_id = t2.second_id;

-- QUERY PLAN                                                                                                                  |
-- ----------------------------------------------------------------------------------------------------------------------------+
-- Hash Join  (cost=21.58..40.17 rows=363 width=142) (actual time=1.349..1.538 rows=363 loops=1)                               |
--   Hash Cond: (t2.second_id = t1.second_id)                                                                                    |
--   ->  Seq Scan on my_table_2 t2  (cost=0.00..17.63 rows=363 width=114) (actual time=0.482..0.584 rows=363 loops=1)   |
--   ->  Hash  (cost=14.79..14.79 rows=543 width=28) (actual time=0.839..0.839 rows=543 loops=1)                               |
--         Buckets: 1024  Batches: 1  Memory Usage: 43kB                                                                       |
--         ->  Seq Scan on my_table_1 t1  (cost=0.00..14.79 rows=543 width=28) (actual time=0.725..0.786 rows=543 loops=1)|
--               Filter: (id < 10)                                                                                          |
-- Planning Time: 0.212 ms                                                                                                     |
-- Execution Time: 1.567 ms                                                                                                    | 
План запроса дополнился новой информацией: actual time (в миллисекундах), cost (в условных единицах). Также появилась реальная характеристика loops, которая показывает, сколько раз выполнился конкретный этап. Ещё одна полезная информация — максимальное потребление памяти, число групп и пакетов хеша для хеш-таблицы.
Merge Join
Merge Join — это соединение слиянием данных нескольких таблиц. Для него нужно, чтобы входные данные были отсортированы по ключам условия соединения. Cуть метода — в сортировке данных по алгоритму слияния и сравнению уже отсортированных данных.
Seq Scan в совокупности с сортировкой часто бывает выгодней, чем обращение по индексу: например, если нужно обработать большой объём строк, поскольку обращения к диску не упорядочены при сканировании по индексу. Merge Join работает эффективнее на больших выборках с отсортированными или частично отсортированными данными. 
Работу Merge Join можно визуализировать следующим образом:
Пример соединения слиянием:

EXPLAIN 
SELECT * 
FROM my_table_3 t1, my_table_4 t2 
WHERE t1.id < 10 AND t1.second_id = t2.second_id;

-- QUERY PLAN                                                                                                    |
-- --------------------------------------------------------------------------------------------------------------+
-- Merge Join  (cost=38.38..75.98 rows=543 width=54)                                                             |
--   Merge Cond: (t2.second_id = t1.second_id)                                                                                 |
--   ->  Index Scan using my_table_4_pkey on my_table_4 t2  (cost=0.29..564.02 rows=12016 width=26)              |
--   ->  Sort  (cost=38.10..39.45 rows=543 width=28)                                                             |
--         Sort Key: t1.id                                                                                       |
--         ->  Seq Scan on my_table_3 t1  (cost=0.00..13.43 rows=543 width=28)                                   | 
Чтобы помочь планировщику подобрать более выгодный план, можно заранее посчитать расширенную статистику для таблиц. Сделать это можно с помощью CREATE STATISTICS и ANALYZE. Например, вот так:

CREATE STATISTICS stats (dependencies) ON column_a, colum FROM my_table;

ANALYZE my_table; 
Асимптотическая сложность алгоритмов
Часто при исследовании запросов, выполнении оптимизации и даже на собеседованиях на позицию инженера данных, администратора БД, разработчика требуется оценить асимптотическую сложность алгоритмов в нотации O-большое (Big-O). Асимптотическая сложность в нотации Big-O определяет количество целостных операций, которые нужно совершить, чтобы закончить работу алгоритма. Целостной операцией является, например, проход по элементам выборки. 
Пример 
В таблице table_name 100 строк. Обычный запрос SELECT name, age FROM table_name WHERE name = 'Alex'; выполнит перебор всех элементов и сравнит каждое значение колонки name со значением 'Alex': пройдёт по всем 100 строкам и выполнит 100 целостных операций. В нотации Big-O асимптотическая сложность такого алгоритма O(n), где n-количество операций (пройденных строк). В нашем случае это 100. 
Сравним сложности алгоритмов Nested Loop, Hash Join, Merge Join:
В худшем случае	В среднем	В лучшем случае	Пояснение
Nested Loop	O(M*N)	O(M*N)	O(M*N)	O(M*N), где M — количество строк первой таблицы, N — количество строк второй таблицы. При вложенном цикле в любом случае нужно пройтись по каждому элементу из второй таблицы на каждый элемент первой таблицы.
Hash Join	O(M+N)	O(M+N)	O(M+N)	O(M+N), где M — количество строк первой таблицы, N — количество строк второй таблицы. Для начала нужно составить хеш-таблицу, пройдя по всем строкам наименьшей таблицы. Для построения хеш-таблицы берётся наименьшая, так как создание хеша тоже требует ресурс CPU и память для хранения полученной хеш-таблицы, и чтобы минимизировать расход этого ресурса, используется таблица с меньшим количеством строк. А далее нужно пройтись по всем строкам второй таблицы.
Merge Join	O(Mlog(M) + Nlog(N))	O(M + N*log(N))
или
O(M*log(M) + N)	O(M+N)	O(MlogM + NlogN), где M — количество строк первой таблицы, N — количество строк второй таблицы. Логарифмы появляются из-за алгоритма сортировки слиянием, оценка сложности алгоритма сортировки слиянием в нотации Big-O — Nlog(N). Это значит, что в худшем случае, когда обе таблицы не отсортированы, нужно будет применить два раза сортировку слиянием.
O(M + Nlog(N)) или O(M*log(M) + N) — в среднем случае, когда отсортирована только одна из таблиц, необходимо выполнить сортировку слиянием только для одной таблицы, а по другой просто пройтись, чтобы выполнить сравнение строк с первой таблицей.
O(M+N) — в лучшем случае, когда обе таблицы отсортированы, достаточно просто пробежаться одновременно по каждой, сравнивая строки.
Планировщик запросов и то, как он устроен, — непростое программное обеспечение в СУБД. Даже самые опытные инженеры данных могут не знать до конца всех тонкостей его работы, но они знают, что нужно делать, чтобы этот план изменить. В следующих уроках дадим несколько советов и предложений по оптимизации запросов.
