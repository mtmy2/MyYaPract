Паттерн Transactional Outbox


Паттерн Transactional Outbox
БД, с которой вы работаете, берёт данные из сервиса-источника. Чтобы обеспечить передачу данных из сервиса в БД без потерь, разработчики системы-источника реализовали специальный паттерн Transactional Outbox, который посредством транзакций заполняет таблицу outboх и поддерживает согласованность данных в источнике и приёмнике. 
Что такое паттерн
Паттерн, или шаблон проектирования, — это устоявшийся способ решения типовой задачи. В нашем случае частая задача — выгрузить данные из сервиса-источника.
Есть разные паттерны для выгрузки данных, и у каждого — свои плюсы и минусы. Можно, например, вставлять данные сразу и в БД источника, и в приёмник. Но если СУБД источника и приёмника различны, то единую транзакцию для передачи данных между системами открыть не получится. В случае ошибки данные добавятся только в источник, а в приёмнике эти записи потеряются или возникнут фантомы.
Другой шаблон — периодически забирать данные из БД источника с помощью снапшота. Фантомы в приёмнике исключаются, потому что читаются только те данные, которые были записаны в источник, но при этом могут потеряться изменения, случившиеся между снапшотами. Периодическое вычитывание данных также создаёт дополнительную нагрузку на систему-источник.
Поскольку БД системы-источника — это PostgreSQL, то для выгрузки данных решили использовать соответствующий паттерн, транзакционный. Шаблон Transactional Outbox тоже неидеален, но зато предотвращает пропажу записей и появление фантомов и не снижает производительность источника.
Как работает паттерн Transactional Outbox
Паттерн Transactional Outbox может применяться ко всем СУБД, в которых есть механизм транзакций и удобного обращения к единичным строкам или объектам. 
Работа паттерна Transactional Outbox выглядит так:
Описание иллюстрации в тексте ниже.
В системе-источнике заводится специальная таблица outbox. Когда данные в основной таблице БД изменяются, то изменения дублируются и в outbox: 
Если объект вставляется, то он вставляется в две таблицы сразу.
Если данные обновляются, то в основной таблице обновляется строка, а в outbox вставляется новая запись. Новая запись содержит полную версию данных, даже если поменялось всего одно поле.
Данные записываются и фиксируются в основной таблице и таблице outbox гарантированно одновременно, потому что изменения выполняются в единой транзакции. Чтобы передать данные из таблицы outbox в систему-приёмник, в источнике заводится периодический процесс, который читает данные из outbox и отправляет их в приёмник. После того как данные передадутся в приёмник, они удаляются из outbox.
Когда вы выбираете этот паттерн для своих задач, помните, что у него есть два недостатка:
Возможна повторная отправка данных.

Данные могут быть уже вычитаны и отправлены, но запись об этой отправке сделать не получилось. В таком случае данные будут отправлены повторно.
Дополнительная нагрузка на таблицу outbox.

Создаётся дополнительная нагрузка на таблицу outbox, т. к. в неё дублируются все записи основной таблицы.
Структура таблицы outbox
В outbox данные хранятся в виде сообщения в любом формате. Например, в нашем случае они хранятся в формате JSON. 
В таблице есть три обязательных поля:
Поле id — в него записывается автогенерируемый первичный ключ записи. Этот id можно использовать как номер версии объектов на случай, если нужно обработать события в том же порядке, в котором они происходили.
Поле payload — чаще всего текстовое поле, в которое записывается сериализованный объект в формате JSON. Паттерн универсален, поэтому в поле payload можно отправлять объекты различных типов.
Поле type — текстовое поле, в котором хранится ключ, указывающий, что за объект хранится в поле payload. Это необходимо для того, чтобы клиент понимал, как правильно десериализовать объект.
Дополнительно в outbox можно включить следующие поля:
Поле object_id — здесь будет храниться ID объекта, который записан в payload.
Поле record_ts — в это поле записывается дата и время появления записи в таблице outbox.
Разработчики могут дать каждому из полей то имя, которое им кажется более подходящим. Хозяева системы-источника дали, например, полю payload название event_value.


Попробуйте самостоятельно написать DDL-скрипт для организации паттерна Transactional Outbox. Другими словами, создайте таблицу outbox в схеме public. Таблица должна содержать следующие поля:
id: INT (PRIMARY KEY с автоинкрементом по конструкции GENERATED ALWAYS AS IDENTITY)
object_id: INT
record_ts: TIMESTAMP
type: VARCHAR
payload: TEXT



create table if not exists outbox (
    id int primary key generated always as identity,
    object_id int not null,
    record_ts timestamp not null,
    type varchar not null,
    payload text not null
)