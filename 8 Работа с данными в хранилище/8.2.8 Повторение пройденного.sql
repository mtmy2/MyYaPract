Повторение пройденного
В этой теме вы подробнее изучили, как работать с витриной: научились инкрементально загружать данные и вспомнили, как использовать представления. Время повторить пройденное.
Что такое витрина данных
Витрина данных — это таблица с данными, которые были выбраны для решения конкретной задачи или набора задач из одной предметной области. Сведения из витрины несут информацию, на основании которой бизнес может скорректировать маркетинговый план, сформировать целевую аудиторию продукта или доработать сервис.
Пример витрины
id	type	max_interest_rate	min_interest_rate	max_sum_loan	min_sum_loan	max_initial_sum	min_initial_sum	max_loan_term	min_loan_term	median_interest_rate	median_sum_loan	median_initial_sum	median_loan_term	trend_previous_period_percent	approved_percent	total_count
1	mortgage	14	5	20 000 000	5 000 000	15 000 000	2 000 000	30	10	8.3	8 000 000	5 000 000	20	-14	87	37
2	auto	18	7	5 000 000	300 000	4 000 000	300 000	5	1	12.1	1 000 000	1 000 000	3	25	95	84
Как строится витрина данных
Алгоритм, по которому строится витрина:
Построить DDL витрины
1. Изучить данные на источнике
2. Определить типы данных и ограничения
Наполнить витрину данными
1. Продумать архитектуру формирования данных в витрине (вставка и обновление)
2. Реализовать скрипт расчёта и переноса данных в витрину
Чтобы верно определить типы и ограничения и построить DDL, нужно изучить данные, на основе которых будет строиться витрина, и понять, как витрина будет использована в дальнейшем. Типы данных и ограничения подбирайте в зависимости от смысла значений в столбце. 
Чтобы перенести в таблицу данные, нужно понять, как верно их преобразовать — из исходного состояния в DWH до целевого в витрине — а затем написать SQL-запросы для этих преобразований. 
Чтобы вам было проще преобразовать данные, продумывайте структуру изменений от обратного: сначала решите, как поэтапно изменить целевые данные до исходных, а запросы уже пишите в «правильном» порядке — от исходных к целевым. 
Как работать с витриной с помощью CTE
Общие табличные выражения позволяют строить промежуточные выборки или таблицы и на их основе делать результирующий запрос. Это могут быть и DML- и DDL-запросы, а конструкция будет следующая:

WITH 
A AS (
-- SQL A
), 
B AS (
-- SQL B
)
-- SQL C; 
WITH — ключевое слово;
А — текстовое наименование выборки;
после AS в скобках пишется запрос с промежуточной выборкой.
Наименованных выборок и блоков с запросами может быть несколько, только нужно разделить их запятыми. 
Виды витрин
Существуют статичные и динамичные витрины данных. Статичные витрины собираются на основе неизменяющихся данных. Такие данные нужно обработать всего лишь один раз, а затем проанализировать. Статичные данные не требуется снова исследовать через какое-то время. 
Как обновлять витрину
Первый метод обновить значения — удалить текущую таблицу с витриной и выполнить ещё раз запрос, который строит эту самую витрину. Способ самый простой, но не самый безопасный: момент, когда вы удалили таблицу, но ещё не успели создать новую, — блокер для пользователей витрины.
Самый оптимальный метод — инкрементальная загрузка. Инкрементальная загрузка — это метод обновления витрины, когда изменяются не все данные, а только те, которые получили новые значения. Этот подход более сложный, чем простой пересчёт всей витрины: процесс разбивается на несколько этапов и создаётся дополнительная таблица. 
Существует два основных способа инкрементальной загрузки:
Первый способ предполагает наличие дополнительной таблицы, в которой каждая строчка — время последнего обновления данных в витрине на основе даты их загрузки в DWH.
Второй способ подразумевает использование паттерна Transactional Outbox. Работа паттерна выглядит так:

Что такое VIEW
VIEW (пер. с англ. «представление», произносится как «вью») — это табличный результат SELECT-запроса, но, в отличие от обычной таблицы в СУБД, результат запроса для представления не записывается на диск, а содержится в оперативной памяти. При этом к VIEW можно обращаться как к обычной таблице, но данные при каждом обращении будут заново пересчитаны с помощью SELECT-запроса. 
Виды VIEW
Постоянное VIEW — представление по умолчанию, которое доступно всегда после его создания.
TEMPORARY VIEW — временное представление, которое автоматически удаляется, когда заканчивается сеанс.
RECURSIVE VIEW — рекурсивное представление, в основе которого находятся рекурсивные запросы, например, CTE-запрос с рекурсией.
MATERIALIZED VIEW — материализованное представление: данные, которые были получены из запроса, будут сохранены на диск, но их нельзя будет изменить с помощью INSERT или UPDATE. Материализованное представление можно сравнить с таблицей, из которой можно только читать данные (READ ONLY). Запрос к MATERIALIZED VIEW не будет выполнять перерасчёт данных, а вернёт те, что были сохранены при первом расчёте. Чтобы обновить данные в материализованном представлении, нужно воспользоваться командой REFRESH MATERIALIZED VIEW view_name.
Системные представления
В PostgreSQL также есть множество системных представлений, которые позволяют получить полезную техническую информацию о СУБД. Вот некоторые из них:
pg_tables — представление с общей информацией о существующих таблицах.
pg_views — представление с общей информацией о существующих представлениях.
pg_user — представление с общей информацией о существующих пользователях.
pg_indexes — представление с общей информацией о существующих индексах.
С полным списком системных представлений вы можете ознакомиться здесь.
Как создавать VIEW
Чтобы создать представление в PostgreSQL, нужно воспользоваться следующим синтаксисом:

CREATE [ OR REPLACE ] [ TEMP | TEMPORARY ] [ RECURSIVE ] VIEW имя [ ( имя_столбца [, ...] ) ]
    [ WITH ( имя_параметра_представления [= значение_параметра_представления] [, ... ] ) ]
    AS запрос
    [ WITH [ CASCADED | LOCAL ] CHECK OPTION ] 



    