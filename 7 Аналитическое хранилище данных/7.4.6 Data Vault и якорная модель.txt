Современные модели DWH: Data Vault и якорная модель
Современные методологии построения DWH также называют «гибкими»: они позволяют быстро предоставлять результат — витрины или отчёты — бизнесу и дают возможность осуществлять итеративную доработку хранилища, что благотворно влияет на его адаптацию к постоянно меняющимся требованиям бизнеса. В этом уроке вы познакомитесь с двумя такими методологиями — Data Vault и «Якорная модель».
Про Data Vault и якорную модель
Американский специалист по данным Дэн Линстедт разработал модель Data Vault в 1990-х годах и представил её публике в 2000 году. В пяти статьях для „Data Administration Newsletter“ Линстедт подробно описал основную концепцию этой модели, правила её создания и соединения основных элементов (таблиц), привёл примеры применения модели для решения задач пользователей и методы загрузки данных в хранилище. Этот подход был разработан во время создания хранилища данных для Министерства Обороны США и показал свою эффективность. В 2013 году Линстедт представил обновлённую версию 2.0, которая была адаптирована под новые технологии (NoSQL, Hadoop) и новые требования к DWH.
В 2004 году в Швеции впервые применили якорную модель для создания хранилища данных страховой компании. Ларс Рённбек представил эту модель на международной арене в 2007 году на конференции Transforming Data with Intelligence (TDWI) в Амстердаме. Его презентация привлекла внимание участников конференции и стала стимулом для формального описания модели. С того времени Ларс Рённбек вместе с Олле Регардтом и командой факультета компьютерных и системных наук Стокгольмского университета проводили исследования по якорному моделированию. В 2008 году на 28-й Международной конференции по концептуальному моделированию была опубликована первая статья, формализующая якорное моделирование, которая была удостоена награды за лучшую работу.
Архитектура Data Vault
В подходе Линстедта данные из операционных систем прежде всего поступают в слой сырых данных (staging area). Он позволяет снизить нагрузку на системы-источники при выполнении запросов. Таблицы staging-слоя по структуре совпадают с таблицами источников. Они также обогащены системными колонками со значениями хэшей бизнес-ключей, информацией об источнике данных, временем загрузки и др.
Следующий этап — разбить таблицы staging-слоя на хабы, ссылки и сателлиты в слое сырой data vault, или raw data vault.
Схема изображает связи хабов, ссылок и сателлитов. Принципы их связей описаны ниже.
Это основные компоненты Data Vault:
Хаб (hub) — таблица, соответствующая бизнес-сущности (напр., Заказ, Адрес, Клиент). Содержит бизнес-ключ из одного или нескольких полей, хэш-ключ от бизнес-ключа и системные поля (время загрузки, идентификатор источника и другие).
На схеме две таблицы, каждая из которых изображает хаб. 
Первая h_client: 
| **client_hash_key** | **UUID** | 
| -------- | -------- |
| client_name | TEXT |
| load_id | TIMESTAMP |
Вторая h_address: 
| **address_hash_key** | **UUID** | 
| -------- | -------- |
| address_name | BIGIT |
| load_id | TIMESTAMP |
Ссылка (link) — таблица, связывающая несколько хабов связью многие-ко-многим. Содержит хэш-ключи связываемых хабов, собственный хэш-ключ, построенный на хэш-ключах связываемых хабов, и те же системные поля, что и хаб.
Теперь на схеме три таблицы, новая таблица изображает ссылку и стоит между двумя хабами. 
Таблица l_client_address:
| **link_hash_key** | **UUID** | 
| -------- | -------- |
| client_hash_key | UUID |
| address_hash_key | UUID |
| address_hash_key | TIMESTAMP |
По client_hash_key она связана с таблицей h_client, по address_hash_key — с таблицей h_address.
Сателлит (satellite) — таблица, содержащая описательные атрибуты хаба или ссылки. Сателлит может хранить историю изменения: проще всего для этого завести поле с хэшем от всех описательных атрибутов. Сателлит содержит хэш-ключ (тот же, что и в хабе), описательные атрибуты, хэш от всех описательных атрибутов и системные поля (те же, что в линках и хабах). Для хаба или ссылки может существовать сколько угодно сателлитов — это позволяет разделять описательные атрибуты по глубине хранения, периодичности сбора и другим параметрам.
К каждой из трёх таблиц выше добавляется по таблице снизу. 
Для h_client — таблица s_client, связанная с ней по client_hash_key:
| **client_hash_key** | **UUID** | 
| -------- | -------- |
| client_phone_number | TEXT |
| load_dttm | TIMESTAMP |
| hash_diff | UUID |
Для l_client_address — s_client_address, связанная с ней по link_hash_key:
| **link_hash_key** | **UUID** | 
| -------- | -------- |
| registration_date | TIMESTAMP |
| load_dttm | TIMESTAMP |
| hash_diff | UUID |
Для h_address — s_address, связанная с ней по address_hash_key:
| **address_hash_key** | **UUID** | 
| -------- | -------- |
| country_name | TIMESTAMP |
| city_name | TEXT |
| street | TEXT |
| building | TEXT |
| post_index | TEXT |
| load_dttm | TIMESTAMP |
| hash_diff | UUID |
При загрузке данных в слой raw data vault данные не обрабатываются дополнительно. Если нужны агрегация или другая обработка данных, то вводится дополнительный слой — business vault. Он строится по тем же принципам, что и raw data vault, но содержит обработанные данные — агрегированные или приведённые к нужной единице измерения.
Ну и для того, чтобы пользователю не пришлось страдать, объединяя десятки таблиц для получения необходимого среза данных, в концепции Data Vault обязательно есть слой витрин (data mart).
Архитектура якорной модели
Якорная модель похожа на Data Vault: для неё тоже обязателен промежуточный слой и слой витрин. Но ядро хранилища отличается.
Ядро якорной модели имеет четыре основных элемента: якорь, атрибут, связь и узел.
Якорь (anchor) — таблица, которая хранит только суррогатные ключи и системные поля — ссылку на источник, время добавления записи. Натуральные ключи считаются обычными атрибутами. Такой подход усложняет общее понимание модели данных, но позволяет более гибко идентифицировать объект в случае существования одной и той же сущности в разных системах с разными натуральными ключами. В Data Vault для хранения такого объекта пришлось бы заводить несколько хабов — по одному на каждый источник с индивидуальным натуральным ключом. В якорной модели существует один якорь, а натуральный ключ размещается в своём атрибуте и используется при загрузке независимо от остальных.

Атрибут (attribute) — это таблица, которая хранит только один описательный атрибут якоря или узла. Если у объекта будет восемь признаков, то и таблиц-атрибутов будет восемь. Выглядит страшно, но можно привыкнуть. Атрибут хранит суррогатный ключ объекта — ссылку на соответствующий якорь, поле для значения атрибута и системные поля (дата загрузки, ссылка на источник).

Узел (knot) — таблица-узел, которая может содержать только один атрибут. Главное назначение узлов — хранение плоских справочников. Такие справочники должны быть статическими и одноуровневыми, например, пол или семейное положение.

Связь (tie) — таблица, связывающая якоря друг с другом, а также узлы и якоря. Связь не может иметь свою таблицу атрибутов, в отличие от Data Vault, где у связей могут быть сателлиты. Связь содержит суррогатные ключи связываемых объектов и системные поля.

Преимущества гибких подходов по сравнению с классическими
Современные подходы к построению DWH решают проблемы классических подходов Кимбалла и Инмона, основанных на «звезде»:
Дублирование данных. Эта проблема свойственна измерениям, хранящим историю изменений: к стандартному набору полей таких таблиц добавляются границы времени действия версии, а на одну строку в источнике появляется несколько версий в хранилище. Такое измерение может занимать существенный объём дискового пространства, хотя большая часть хранящихся в нём данных — просто дубли значений неизменных атрибутов из других строк.
Классические хранилища также часто используют денормализацию для упрощения обращения к данным, а это значит, что часть атрибутов намеренно хранятся в виде значения, а не ссылки на справочник или другое измерение. Это приводит к хранению одной и той же информации в разных таблицах. Гибкие методологии решают эту проблему за счёт отделения изменяемого от неизменного — хранения ключей отдельно от атрибутов.
Жёсткая кардинальность связей. Для фактов и измерений на начальном этапе проектирования строго определяется, могут ли они иметь отношения многие-ко-многим или только один-ко-многим и в какую сторону. Без этого невозможно задать, какая из таблиц содержит первичный ключ, а какая — внешний. При изменении связей в бизнесе достаточно сложно обновить связи в хранилище по типу «звезда» — требуется серьёзная переработка таблиц и их ключей. Гибкие методологии решают эту проблему примерно так же, как проблему дублей, — хранят связи в отдельных таблицах и обрабатывают их как многие-ко-многим (ссылка в Data Vault и связь в якорной модели). Такая структура гибкая по отношению к изменению кардинальностей существующих связей и даже добавлению новых.
Сложность доработки. Чем больше таблицы в хранилище денормализованы, тем сложнее создать универсальные процессы загрузки данных в DWH и раскладки их по слоям. Также стоит учитывать, что поддерживать версионность классического хранилища — сложная задача для ETL и ELT, при которой почти невозможно избежать ошибок. Из-за типизации объектов Data Vault и якорная модель позволяют масштабировать хранилище в модульном режиме: добавление как отдельных атрибутов, так и целых новых предметных областей в такой модели могут быть автоматизированы и управляться метаданными.
Недостатки гибких подходов
Сложность стартового проектирования и разработки. Кроме понимания особенностей всех сущностей гибких подходов (что уже достаточно непростая задача), инженеру нужно уметь применять эти подходы к различным бизнес-областям и требованиям заказчика. Проектирование, разработка и отлаживание ETL- и ELT-процессов для миграции данных из источников в хранилище, а далее — по его слоям, а также разработка витрин на начальном этапе затрачивают много времени и ресурсов специалистов.
Нетривиальный доступ к данным. Построение хранилища по Data Vault или якорной модели приводит к многократному соединению таблиц для доступа к данным. Пользователи, работающие с хранилищем, должны быть ознакомлены со спецификой подходов и корректной работой с их сущностями. Ну и витрин нужно много, без них никуда!
Повышение нагрузки на вычислительные ресурсы. Увеличение количества таблиц и соединений между ними неизбежно ведёт к повышению нагрузки на ресурсы машины. Если их не так много, то загрузка и обновление данных здесь может происходить медленнее, чем в классических моделях.
Почувствуйте себя разработчиками моделей DWH: оцените схемы основного слоя хранилища из проекта для страховой компании и определите, какая схема к какому подходу относится.

Подход Кимбалла
Здесь — денормализованные таблицы фактов и измерений, формирующие ядро хранилища, в схеме «звезда». Поэтому это подход Кимбалла.

Подход Инмона
Структура субъектов в нормализованном виде. Это слой по Инмону.

Data Vault
Таблицы частично нормализованы, есть хабы, сателлиты и линки. Модель — Data Vault. 

Якорная модель
Якорная модель стремится к полной нормализации данных, что обеспечивает высокую степень их целостности.
Про модели DWH — всё! Дальше — задачка от заказчика.

