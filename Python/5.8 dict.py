# Название.
vegetables = ['Помидоры', 'Огурцы', 'Баклажаны', 'Перец', 'Капуста']
# Урожайность с 1 кв. м.
vegetable_yields = [6.5, 4.3, 2.8, 2.2, 3.5]

# Вместо списков создадим словарь.
# При объявлении коллекций (и словарей в том числе) 
# элементы удобнее записывать построчно. 
# Да, так можно!
vegetable_yields_all_in_one = {
    'Помидоры': 6.5,
    'Огурцы': 4.3,
    'Баклажаны': 2.8,
    'Перец': 2.2,
    'Капуста': 3.5
}

# К названию привязана урожайность,
# и все эти данные сохранены в одной коллекции!



status_dict = {
    'one': 1,         # Ключ - строка (str - неизменяемый тип).
    2: 'Число',       # Ключ - число (int - неизменяемый тип).
    (3, 4): 'Кортеж'  # Ключ - кортеж (tuple - неизменяемый тип).
}



# Создадим пустой словарь. Так делают, когда наполнять словарь элементами
# планируется позже.
empty = dict()
print('Печатаем пустой словарь:', empty)

# Словарям принято давать имена в соответствии со смыслом ключей.
vegetables = dict(
    Помидоры=6.5,
    Огурцы=4.3,
    Баклажаны=2.8,
)

print('Печатаем словарь с овощами:', vegetables)



vegetable_yields = dict(
    [
        ('Помидоры', 6.5), 
        ('Огурцы', 4.3), 
        ('Баклажаны', 2.8)
    ]
)

# Получится такой словарь:

vegetable_yields = {
    'Помидоры': 6.5, 
    'Огурцы': 4.3, 
    'Баклажаны': 2.8
}



vegetables = [('Помидоры', 6.5), ('Огурцы', 4.3), ('Баклажаны', 2.8)]

vegetable_yields = dict(vegetables)
print('Словарь из кортежей:', vegetable_yields)



vegetable_yields = [
    ('Помидоры', 6.5), 
    ('Огурцы', 4.3), 
    ('Баклажаны', 2.8), 
    ('Помидоры', 5.1)  # Дубликат ключа.
]

yields_dict = dict(vegetable_yields)
print(yields_dict)



vegetables = dict.fromkeys(['Помидоры', 'Огурцы', 'Баклажаны', 'Перец'])
print('Создали словарь, не передали второй аргумент:', vegetables)

# Вторым элементом передаём в функцию значение, 
# которое будет присвоено всем элементам словаря.
vegetable_yields = dict.fromkeys(['Ананасы', 'Брюква', 'Клюква', 'Артишоки'], 3.2)
print('Создали словарь, вторым аргументом передали 3.2:', vegetable_yields)



vegetables = ['Помидоры', 'Огурцы', 'Баклажаны', 'Перец', 'Капуста']
vegetable_yields = [6.5, 4.3, 2.8, 2.2, 3.5]
vegetable_varieties = ['Красный куб', 'Аллигатор', 'Василёк', 'Тропический закат', 'Арктик']

# Передаём в аргументы функции zip() три последовательности:
zip_collection = zip(vegetables, vegetable_yields, vegetable_varieties)

print('Получили значение такого типа:', type(zip_collection))
print('Напечатать это значение нельзя:', zip_collection)

# Приводим значение zip к списку:
list_from_zip = list(zip_collection)

# Печатаем получившийся список:
print('list_from_zip =', list_from_zip)



# Это список, а элементы списка - кортежи
list_from_zip = [
  # Элемент list_from_zip[0] содержит элементы с индексом 0 из исходных списков.
  ('Помидоры', 6.5, 'Красный куб'),
  # Элемент list_from_zip[1] содержит элементы с индексом 1 из исходных списков.
  ('Огурцы', 4.3, 'Аллигатор'),
  # Элемент list_from_zip[2] содержит элементы с индексом 2.
  ('Баклажаны', 2.8, 'Василёк'), 
  # Элемент list_from_zip[3] содержит элементы с индексом 3.
  ('Перец', 2.2, 'Тропический закат'), 
  # Элемент list_from_zip[4] содержит элементы с индексом 4.
  ('Капуста', 3.5, 'Арктик')
]



vegetables = ['Помидоры', 'Огурцы', 'Баклажаны', 'Перец', 'Капуста']
vegetable_yields = [6.5, 4.3, 2.8, 2.2, 3.5]

# Шаг первый:
# упаковываем списки в zip:
vegetables_zip = zip(vegetables, vegetable_yields)

# Шаг второй:
# преобразуем zip в словарь:
vegetables_info = dict(vegetables_zip)

# Печатаем словарь:
print(vegetables_info)

#Преобразование из zip-объекта в словарь сработает только в том случае, если в zip упакованы две последовательности. В любом другом случае при попытке создать словарь из zip-объекта функция dict() вернёт ошибку.

vegetables = ['Помидоры', 'Огурцы', 'Баклажаны', 'Перец', 'Капуста']  # 5 элементов.
vegetable_yields = [6.5, 4.3, 2.8]  # 3 элемента.

vegetables_info = zip(vegetables, vegetable_yields)

# Приводим к словарю и печатаем:
print(dict(vegetables_info))


# Функция для создания словаря информации об овощах

def create_vegetable_info(vegetables, varieties, yields):
    # Ваш код здесь
    vegetable_info = dict(zip(vegetables, zip(varieties, yields)))
    return vegetable_info

# Тестовые данные:
vegetables = ['Помидоры', 'Огурцы', 'Баклажаны', 'Перец', 'Капуста']
varieties = ['Красный куб', 'Аллигатор', 'Василёк', 'Тропический закат', 'Арктик']
yields = [6.5, 4.3, 2.8, 2.2, 3.5]

# Вызов функции:
print(create_vegetable_info(vegetables, varieties, yields))

