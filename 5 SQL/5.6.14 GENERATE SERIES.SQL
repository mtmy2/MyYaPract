Для возрастающей последовательности начальное значение должно быть меньше финального, а шаг значений — положительным:

SELECT *
FROM GENERATE_SERIES(0, 5, 1) AS ascending_seq;

Для убывающей последовательности начальное значение должно быть больше финального, а шаг значений — отрицательным:

SELECT *
FROM GENERATE_SERIES(10, 0, -2) AS descending_seq; 


Генерировать можно не только целые, но и дробные числа, при этом шаг значений может быть целым или дробным:

SELECT 
    GENERATE_SERIES(0.1, 5, 1) AS seq_1,
    GENERATE_SERIES(15, 0, -2.41) AS seq_2; 


Например, можно сгенерировать последовательность номеров заказов:

SELECT 'order_' || GENERATE_SERIES(1, 5) AS order; 



Чтобы сгенерировать последовательность букв алфавита, понадобятся функции ASCII и CHR:

SELECT
    CHR(ASCII('A') + GENERATE_SERIES(0, 4)) AS eng,
    CHR(ASCII('Я') - GENERATE_SERIES(0, 8, 2)) AS rus; 


Например, можно сгенерировать множество данных timestamp или date, если записать стартовое или финальное значение в виде timestamp или date:

SELECT *
FROM GENERATE_SERIES('2023-05-01 00:00'::timestamp, '2023-05-03 12:00', 
                    '12 hours') AS time_series; 


Обратите внимание, как задан необходимый интервал времени в примере выше: указано количество часов — '12 hours'. 
В GENERATE_SERIES можно использовать различные интервалы и задавать их через тип interval. 
Интервалы времени могут соответствовать:
годам — years,
месяцам — months,
неделям — weeks,
дням — days,
часам — hours,
минутам — minutes,
секундам — seconds,
миллисекундам — milliseconds.
Например, интервал в 15 минут записывают так: '15 minutes'. Можно задавать комбинированные интервалы: например, 1 месяц и 15 секунд — '1 month 15 seconds'. 
Также в качестве значений можно задавать дробные интервалы, например '0.25 hours'. 
Указать интервал можно как во множественном числе, так и в единственном. Например, '15 minutes' = '15 minute'.


Сгенерированную последовательность целочисленных значений можно использовать для создания множества дат.
 В этом случае последовательность дат формируется так: к заданной дате добавляют определённое количество дней. Шаг значений должен быть целым числом:

SELECT '2023-05-01'::date + GENERATE_SERIES(0, 5) AS dates; 


Перекрёстно соединяем множества
Функцию GENERATE_SERIES можно использовать для генерации нескольких множеств, у которых есть перекрёстные взаимоотношения. 
В этом случае значения одного множества будут созданы для каждого значения другого множества:

SELECT 
    CHR(ASCII('A') + a) AS first_level, 
    b AS second_level
FROM 
    GENERATE_SERIES(0, 2, 1) AS a, 
    GENERATE_SERIES(10, 13, 1) AS b;
    
/* обратите внимание, что использование псевдонимов для GENERATE_SERIES() после FROM
отличается от обычных таблиц */ 

Для каждого значения первого множества, представленного последовательностью букв от А до C, было создано множество значений от 10 до 13. 
Это получилось потому, что при генерации во FROM двух множеств, указанных через запятую, происходит их перекрёстное (декартово) соединение — аналог CROSS JOIN.


Генерируем последовательность случайных чисел и букв
Также GENERATE_SERIES поможет создать множество строк со случайными значениями. Ещё понадобится функция RANDOM.
Вот как это делается:
GENERATE_SERIES создаёт последовательность из строк,
RANDOM генерирует необходимые значения.
Например, такой запрос создаст последовательность из пяти случайных чисел от 0 до 100:

SELECT ROUND(RANDOM()*100) AS random_value
FROM GENERATE_SERIES(1, 5, 1) AS seq 



Затем этот запрос объединит все символы в одну строку с помощью функции STRING_AGG:

SELECT 
    STRING_AGG(CHR(65 + FLOOR(RANDOM() * 26)::integer), '') AS random_letters
FROM 
    GENERATE_SERIES(1, 10) AS num_of_letters; 


И наконец, этот запрос создаст ещё одно множество значений, которое определит общее количество строк (в этом примере — пять строк). 
Затем соединит множества с помощью перекрёстного соединения и сгруппирует по этому столбцу итоговый результат:

SELECT 
    number_of_rows,
    STRING_AGG(CHR(65 + FLOOR(RANDOM() * 26)::integer), '') AS random_letters
FROM 
    GENERATE_SERIES(1, 5) AS number_of_rows, 
    GENERATE_SERIES(1, 10) AS num_of_letters
GROUP BY number_of_rows; 


Этот запрос можно ещё оптимизировать — если не нужно выводить значения number_of_rows, то генерацию этого множества можно сразу вставить в GROUP BY:

SELECT STRING_AGG(CHR(65 + FLOOR(RANDOM() * 26)::integer), '') AS random_letters
FROM GENERATE_SERIES(1, 10) AS num_of_letters
GROUP BY GENERATE_SERIES(1, 5); 


Генерируем последовательности случайных значений даты и времени
Ещё совместно использовать функции GENERATE_SERIES и RANDOM можно для генерации множества случайных значений времени. 
Разберём на примере:

SELECT '2023-05-01 00:00'::timestamp + RANDOM() * ('24 hours'::interval) AS random_time
FROM GENERATE_SERIES(1, 5); 


Генерируем последовательность значений при агрегации данных
Бывает, возникает необходимость создать множество значений с определённой последовательностью, чтобы затем сагрегировать по ним данные.
Например, нужно подсчитать количество фильмов в таблице movie, вышедших с 2000 по 2010 год включительно:

SELECT movie_year, COUNT(m.film_id) AS movie_num
FROM GENERATE_SERIES(2000, 2010, 1) AS movie_year
LEFT JOIN movie AS m ON movie_year = m.release_year 
-- присоединит таблицу с данными о фильмах
GROUP BY movie_year 
-- сгруппирует данные по году выпуска фильма
ORDER BY movie_year 
-- отсортирует вывод в порядке возрастания года выпуска фильма 

Сначала функция GENERATE_SERIES сгенерировала последовательность строк с годами от 2000-го до 2010-го включительно. 
Затем присоединились данные по фильмам и подсчиталось количество фильмов за каждый год выхода фильма. 
Изначально таблица movie содержит данные о фильмах, вышедших после 2004 года, и поэтому в результатах 2000–2004 стоят нули. 
Такой подход позволяет заполнять пропуски в данных при их агрегации по определённым значениям.


