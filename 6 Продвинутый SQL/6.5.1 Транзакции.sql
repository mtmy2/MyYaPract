Транзакции
До сих пор вы изучали, как выполнять отдельные команды SQL. Бывает, что решить задачу одной командой не получается, и надо выполнить несколько команд, связанных друг с другом. Разберём такую задачу на примере.
Нужно перевести деньги в сумме 500 некоторых условных единиц с одного счёта на другой. Это означает, что на одном счёте нужно уменьшить баланс на эту сумму, а на другом — увеличить на ту же сумму. Такая операция называется банковской транзакцией.
Есть две таблицы: 
accounts — содержит информацию о балансах на счетах.
account_transactions — хранит записи о всех транзакциях по счетам.
После успешного перемещения денег нужно добавить запись о транзакции в таблицу account_transactions. Баланс не должен быть отрицательным, но может быть равным нулю, а переводимые суммы должны быть положительными.
Теперь рассмотрим таблицы.
В таблице accounts такие столбцы:
id — первичный ключ, автоматически генерируется при вставке новой строки.
account_number — номер счёта.
balance — текущий остаток на счёте.
last_update — время и дата последнего обновления строки.
Создайте схему bank для банковских данных, в ней создайте таблицу accounts и заполните её данными, выполнив этот скрипт:

CREATE SCHEMA bank;

CREATE TABLE bank.accounts (
    id SERIAL PRIMARY KEY,
    account_number VARCHAR NOT NULL,
    balance DECIMAL(12,2) NOT NULL CHECK (balance >= 0),
    last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

INSERT INTO bank.accounts (account_number, balance, last_update)
VALUES 
    ('BG22UBBS890', 5000.00, '2023-05-28 00:00:00'),
    ('BG79UBBS901', 3000.00, '2023-05-21 00:00:00'),
    ('BG31UBBS012', 15000.00, '2023-05-22 00:00:00'); 
Вот что должно получиться:
id	account_number	balance	last_update
1	BG22UBBS890	5000.00	2023-05-28 00:00:00
2	BG79UBBS901	3000.00	2023-05-21 00:00:00
3	BG31UBBS012	15000.00	2023-05-22 00:00:00
В таблице account_transactions такие столбцы:
id — первичный ключ, автоматически генерируется при вставке новой строки.
account_id — внешний ключ, связывает каждую операцию с определённым счётом в таблице accounts.
transaction_amount — сумма операции.
transaction_type — тип операции. Например, вклад 'D' или снятие 'W'.
created_at — дата и время операции.
Создайте таблицу и заполните её данными, выполнив этот скрипт:

CREATE TABLE bank.account_transactions (
    id SERIAL PRIMARY KEY,
    account_id INTEGER REFERENCES bank.accounts(id),
    transaction_amount DECIMAL(12,2) NOT NULL CHECK (transaction_amount > 0),
    transaction_type CHAR(1) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

INSERT INTO bank.account_transactions 
      (account_id, transaction_amount, transaction_type, created_at)
VALUES 
    (1, 1000.00, 'D', '2023-05-30 00:00:00'),
    (1, 500.00, 'W', '2023-05-29 00:00:00'),
    (2, 1500.00, 'D', '2023-05-31 00:00:00'),
    (3, 5000.00, 'W', '2023-05-30 00:00:00'); 
Вот что должно получиться:
id	account_id	transaction_amount	transaction_type	created_at
1	1	1000.00	D	2023-05-30 00:00:00
2	1	500.00	W	2023-05-29 00:00:00
3	2	1500.00	D	2023-05-31 00:00:00
4	3	5000.00	W	2023-05-30 00:00:00
Чтобы перевести 500 условных единиц с одного счёта на другой и добавить запись о транзакции в таблицу account_transactions, нужно последовательно выполнить четыре запроса. 
Выполнять запросы в этом уроке не нужно. Сейчас ваша задача — познакомиться с ними, так как эти запросы понадобятся вам в следующих уроках.
Запрос № 1. Уменьшает сумму на счёте 'BG22UBBS890' с id = 1 на 500: 

UPDATE bank.accounts
SET balance = balance - 500,
    last_update = CURRENT_TIMESTAMP
WHERE account_number = 'BG22UBBS890'; 
Запрос № 2. Увеличивает сумму на счёте 'BG31UBBS012' с id = 3 на 500:

UPDATE bank.accounts
SET balance = balance + 500,
    last_update = CURRENT_TIMESTAMP
WHERE account_number = 'BG31UBBS012'; 
Запрос № 3. Добавляет строку в таблицу account_transactions со списанием средств:

INSERT INTO bank.account_transactions 
    (account_id, transaction_amount, transaction_type)
VALUES 
    (1, 500, 'W'); 
Запрос № 4. Добавляет строку в таблицу account_transactions с пополнением счёта:

INSERT INTO bank.account_transactions 
    (account_id, transaction_amount, transaction_type)
VALUES 
    (3, 500, 'D'); 
Дальше в уроке будем ссылаться на эти запросы по номерам.
Теперь представьте — вы начали выполнять запросы, и тут после запроса № 2 произошёл сбой сервера, база данных перестала отвечать, и оставшиеся запросы не выполнились. 
Получается, что суммы на счетах изменились, но в таблице account_transactions информации об этих операциях нет. Когда понадобится собрать историю операций по счёту, суммы не сойдутся, и у клиентов возникнет вопрос к банку:
Такая ситуация неприемлема. Так же, как если бы выполнился только запрос № 1, а остальные нет: деньги ушли с одного счёта, но не пришли на другой, и в таблице операций по счёту данных по этой операции нет.
Чтобы предотвратить такие проблемные ситуации, необходимо выполнять все запросы как неразрывный процесс. Для этого в базах данных есть инструмент, который называется так же, как банковская операция — транзакция.
Транзакция в БД — это одна или несколько операций, которые выполняются как единое целое. Если все операции выполняются успешно, транзакция считается завершённой, и все изменения, внесённые в базу данных, становятся постоянными. Однако если хотя бы одна операция не выполняется, транзакция «откатывается», и все изменения, внесённые в базу в рамках этой транзакции, отменяются.
Выберите все ситуации, в которых необходимы транзакции.


Правильный ответ
Банковские операции, такие как перевод денег с одного счёта на другой.
Перевод денег включает в себя несколько действий: снятие денег с одного счёта, зачисление их на другой и фиксация операции в таблице. Скорее всего, это будет несколько SQL-запросов, которые должны выполняться вместе или вообще не выполняться, — значит, их надо объединить в транзакцию.

Правильный ответ
Списание товара со склада и учёт операции в таблице операций по складу.
Такая задача предполагает создание нескольких SQL-запросов, которые должны выполняться вместе или вообще не выполняться, — значит, их надо объединить в транзакцию.

Добавление нового клиента в базу клиентов.
Скорее всего, добавление клиента — изменение в одной таблице, без изменения данных других таблиц. Поэтому такое добавление можно выполнить отдельным SQL-запросом.

Логирование действий пользователя — добавление информации о выполненных действиях в таблицу.
Добавление записей с логами в таблицу обычно не зависит друг от друга и не влияет на другие таблицы или данные, поэтому их не обязательно объединять в транзакцию. Если какая-то из операций не добавится в лог, это не вызовет противоречия в данных.

Правильный ответ
Перенос старых заказов из одной таблицы в другую.
Такая задача предполагает создание нескольких SQL-запросов, которые должны выполняться вместе или вообще не выполняться, — значит, их надо объединить в транзакцию.

Одиночные запросы на чтение данных.
Когда делают одиночный запрос на чтение данных из одной таблицы, и это не влияет на другие операции и не связано с изменением данных, транзакции обычно не нужны.