Рекурсивный запрос — запрос, который вызывает сам себя. 
В разработке рекурсивные запросы помогают генерировать последовательности чисел, работать с иерархическими структурами, выделять подстроки в строках и т. д. В этом уроке мы рассмотрим пример с генерацией последовательности, а в следующем поговорим о задачах с иерархиями.
Пусть нам нужно заполнить таблицу данными для тестирования и для этого сгенерировать последовательность чисел от 1 до 100. Ранее вы решали эту задачу с помощью функции generate_series. Теперь в качестве простого учебного примера решим её с помощью рекурсивного запроса. 
Как создать рекурсию
Определить первое значение. Оно ещё называется инициализирующим, или начальной точкой рекурсии. Эта часть запроса выполняется только один раз и является нерекурсивной.

В нашей задаче начальная точка рекурсии — число 1.
Написать код для генерации последующих значений. Эта часть запроса рекурсивная, она выполняется много раз. Каждое выполнение этой части называют шагом рекурсии.

В нашей задаче последующее значение получается увеличением текущего на 1. Это и есть шаг рекурсии.

Всего у нас получится 99 шагов — это глубина рекурсии.
Сформулировать условие остановки, такое условие называется базовым случаем рекурсии. Здесь возможны два варианта: мы или задаём условие остановки явно, или не задаём его. 
 a. Когда мы задаём условие остановки, рекурсивная часть выполняется до тех пор, пока не реализуется условие остановки. 
 Это как раз ситуация нашего примера. Когда число станет равным 100, мы закончим генерацию чисел. 
 b. Мы не задаём условие остановки явно. Тогда рекурсивная часть выполняется до тех пор, пока не закончатся данные, которые возвращаются рекурсивным запросом. Подробнее такой вариант мы разберём в этой теме позже.
Таким образом рекурсия работает, пока не произойдёт базовый случай. Каждый шаг рекурсии, при котором не выполняется условие базового случая, называется рекурсивный случай. В нашем примере генерации последовательности целых чисел от 1 до 100:
Рекурсивный случай — число находится в промежутке от 1 до 100, базовый случай — число строго равно 100. 
Бывает, что в рекурсии не указан базовый случай или указан так, что он не выполняется. Например, если в нашем примере задать условие остановки WHERE num = num, то рекурсия будет работать «бесконечно», так как такая запись всегда истинна. На практике такой запрос «подвиснет», потребуется его принудительное завершение, и результат не будет получен. 
Рекурсия в PostgreSQL отличается от рекурсии в языках программирования общего назначения. В PostgreSQL такие запросы выполняются итерационно, то есть в цикле. Поэтому при «зависании» рекурсии происходит не переполнение стека вызовов, а зацикливание.
Чтобы обратиться к запросу, нужно присвоить ему имя. Обращаться к запросу по имени позволяют CTE. Чтобы из CTE обратиться к самому себе, необходимо после ключевого слова WITH указать RECURSIVE. 
Общий вид рекурсивного запроса SQL:

WITH RECURSIVE наименование_CTE[(<список_столбцов_CTE>)] AS (
     <запрос_только_для_первого_значения>
    UNION [ALL]
    SELECT <список_столбцов_CTE> FROM <наименование_CTE> 
    [WHERE <условие>]
)
SELECT <список_столбцов_CTE> FROM <наименование_CTE>
[LIMIT <условие>]; 


Нерекурсивная и рекурсивная части объединяются с помощью UNION [ALL]. Если нужно убрать дубликаты значений, используют UNION. 
Условие остановки рекурсивной части можно задать с помощью фильтра WHERE или LIMIT в конце запроса.
Для генерации последовательности чисел от 1 до 100 получим такой код: 

WITH RECURSIVE test_data AS (
    SELECT 1 AS num
    UNION ALL
    SELECT num + 1 
    FROM test_data
    WHERE num < 100
)
SELECT num 
FROM test_data; 


Здесь в запросе:
test_data — это наименование для обобщённого табличного выражения. Оно содержит один столбец num.
CTE test_data состоит из двух SELECT запросов, результаты работы которых объединены оператором UNION ALL.
Первый запрос SELECT нерекурсивный. Он используется для шага инициализации и заполняет CTE test_data первой строкой со значением 1 в столбце num.
Второй запрос SELECT рекурсивный, в нём происходит обращение к тому же CTE test_data, которое выполняется в запросе. Поэтому, когда второе значение будет получено, запрос не прекратит выполнение и повторно обратится к test_data.
С помощью num + 1 мы получаем следующее число, далее снова обращаемся к test_data и т. д.
Ограничить выборку в запросе помогает WHERE num < 100. Когда мы достигнем 100, запрос не обратится больше к CTE test_data, рекурсия остановится и мы получим результат.
Больше о процессе обработки рекурсивных запросов можно прочитать в соответствующем разделе документации. 
Выражение остановки важно поместить внутрь CTE, чтобы ограничить рекурсию. Если переместить WHERE num < 100 во внешний запрос, то рекурсия остановится только когда будет израсходована доступная оперативная память. Другими словами, если запустите код ниже, программа «зависнет». 

WITH RECURSIVE test_data AS (
    SELECT 1 AS num
    UNION ALL
    SELECT num + 1 
    FROM test_data
)
SELECT num 
FROM test_data
WHERE num < 100;    -- Условие WHERE во внешнем запросе 



Второй способ завершить рекурсию — добавить выражение с LIMIT во внешнем запросе. Например, при генерации последовательности чисел от 1 до 100 это будет выражение LIMIT 100. 
PostgreSQL разрешает разместить LIMIT только во внешнем запросе. При этом мы рекомендуем использовать LIMIT только в случаях, когда другим способом рекурсию остановить не получится. Основных причины две: 
В некоторых СУБД, например Oracle или Microsoft SQL Server, оператор LIMIT отсутствует. В этих СУБД есть другие операторы с аналогичной функциональностью, но они могут иметь свои особенности и ограничения.
Если есть сортировка или сложные соединения таблиц, в PostgreSQL внешний запрос обычно всё равно выбирает результат запроса CTE полностью. В таких случаях остаётся риск «зависания» рекурсии.
Заполним тестовую таблицу не последовательными числами, а случайными значениями. Тогда не получится использовать WHERE и для ограничения рекурсии нужен именно LIMIT:

WITH RECURSIVE test_data AS (
    SELECT FLOOR(RANDOM() * 100) AS num
    UNION ALL
    SELECT FLOOR(RANDOM() * 100) AS num 
    FROM test_data
)
SELECT num 
FROM test_data
LIMIT 100; 


А для нашей задачи теперь осталось добавить INSERT в запрос для того, чтобы сгенерированные данные попали в таблицу для тестирования. Ниже пример для варианта с WHERE:

-- Создаём тестовую таблицу из одного столбца:
CREATE TABLE test (
    num integer
);

INSERT INTO test
WITH RECURSIVE test_data AS (
    SELECT 1 AS num
    UNION ALL
    SELECT num + 1 
    FROM test_data
    WHERE num < 100
)
SELECT num 
FROM test_data; 