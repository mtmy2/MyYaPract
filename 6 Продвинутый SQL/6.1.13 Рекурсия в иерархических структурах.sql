Иерархии
Иерархии часто встречаются в нашей жизни, а иерархические данные тоже нужно как-то хранить и уметь работать с ними. 
Иерархическая структура — это структура в виде «дерева». Её элементы также называют узлами. Схематически можно изобразить её так:
Схема иерархической структуры. Описание — в тексте ниже. 
В иерархии: 
Есть главный элемент — корень дерева, который является «родителем» для остальных узлов — «потомков».
Корневой элемент может быть только один, и у него нет «родителя».
У остальных узлов обязательно должен быть только один «родитель».
Каждый узел может иметь любое число «потомков» или ни одного.
Классический пример иерархии — организационная структура компании:
Схема организационной структуры компании. Корневой элемент — руководитель организации. У него двое подчинённых: руководитель проектного офиса и руководитель отдела разработки. Руководителю проектного офиса подчиняются два менеджера проектов. Руководителю отдела разработки подчиняются тим лид и ведущий тестировщик. Тим лиду подчиняются трое: два разработчика и аналитик. Ведущему тестировщику подчиняются два тестировщика.
Другой пример иерархической структуры — рубрикаторы, например, в каталогах фильмов или товаров. 
Обычно иерархию хранят в одной таблице вместе со всеми связями. Это удобно, так как, чтобы добавить новые связи или уровни иерархии, достаточно добавить строки в таблицу.
Такая иерархическая таблица содержит два обязательных столбца: один с уникальным идентификатором для каждой строки, второй — со ссылкой на идентификатор родительской строки. Например, структура может быть такой: 
Название столбца	Описание
id	идентификатор узла
parent_id	идентификатор родительского элемента для этого узла
name	наименование элемента иерархии
Идентификатор родительского элемента иерархии — это ссылка на столбец id. Родительский идентификатор равен одному из значений идентификаторов для других строк. У корневого узла нет родителя, поэтому для него parent_id = null.
Поскольку идентификатор родителя — это ссылка на столбец той же таблицы, мы можем рекурсивно соединять таблицу саму с собой и выводить иерархию в нужном нам порядке: от одного узла до всех дочерних или в обратную сторону — от дочернего элемента к корневому.  
Строим иерархический запрос
Для примера рассмотрим организационную структуру компании:
Схема организационной структуры той же компании, что и на предыдущей иллюстрации. Корневой элемент — руководитель организации. У него двое подчинённых: руководитель проектного офиса и руководитель отдела разработки. Руководителю проектного офиса подчиняются два менеджера проектов. Руководителю отдела разработки подчиняются тим лид и ведущий тестировщик. Тим лиду подчиняются трое: два разработчика и аналитик. Ведущему тестировщику подчиняются два тестировщика.
Для хранения такой структуры используется таблица company_org. Создадим таблицу — выполняйте вместе с нами. Так вы сможете лучше понять происходящее. 

CREATE TABLE company_org (
    id INTEGER PRIMARY KEY,
    parent_id INTEGER,
    pos_name VARCHAR NOT NULL,
    fio VARCHAR NOT NULL
); 
Наполним таблицу данными:

INSERT INTO company_org (id,parent_id,pos_name,fio) VALUES
    (1,NULL,'Руководитель организации','Голованов А.А.'),
    (2,1,'Руководитель проектного офиса','Иванов Б.И.'),
    (3,1,'Руководитель отдела разработки','Соколов Е.В.'),
    (4,2,'Менеджер проектов','Пушкина Д.Ф.'),
    (5,2,'Менеджер проектов','Петров У.В.'),
    (6,3,'Старший разработчик','Вовченко П.Г.'),
    (7,3,'Ведущий тестировщик','Семёнов Р.В.'),
    (8,6,'Разработчик','Коротков И.Д.'),
    (9,6,'Разработчик','Зимарин Н.Л.'),
    (10,6,'Аналитик','Аксёнова Н.Д.'),
    (11,7,'Тестировщик','Борисов М.Ю.'),
    (12,7,'Тестировщик','Цветкова Л.О.'); 

После выполнения запроса INSERT таблица company_org будет содержать 12 строк. В этих строках записана информация об отношениях между родителями и потомками. На рисунке ниже мы визуализировали эти отношения: стрелки следуют от потомков к родителям по значениям идентификаторов id:
Описание иллюстрации — в тексте и листинге выше
Предположим, что нам для отчёта нужно вывести список сотрудников отдела разработки: всех подчинённых и руководителя отдела. 
Используем шаблон рекурсивного запроса. Первый запрос в CTE устанавливает начальное условие для старта рекурсии. Нам нужен отдел разработки, так что начнём с его руководителя. Соответствующая строка имеет id = 3. 
Начнём запрос, добавим CTE и назовём его dev_department:

WITH dev_department AS (
    SELECT id, parent_id, pos_name, fio
    FROM company_org
    WHERE id = 3
)
SELECT * 
FROM dev_department; 
Теперь — подчинённые: сначала выведем всех подчинённых этого руководителя, а затем подчинённых его подчинённых и так далее по всем уровням иерархии.
Для этого напишем рекурсивный запрос после UNION ALL. В нём соединим основную таблицу company_org и CTE dev_department по столбцу parent_id. 
Получится такой запрос:

WITH RECURSIVE dev_department AS (
    SELECT id, parent_id, pos_name, fio
    FROM company_org
    WHERE id = 3
    UNION ALL
    SELECT org.id, org.parent_id, org.pos_name, org.fio
    FROM company_org org
    INNER JOIN dev_department dev
    ON org.parent_id = dev.id     
)
SELECT * 
FROM dev_department; 

При выполнении этого запроса СУБД создаёт три временные таблицы: 
Общая таблица создаётся в начале выполнения запроса, и в неё последовательно записываются результаты запроса. На каждом шаге рекурсии эта таблица дополняется данными. Когда запрос завершён, именно эта таблица будет результирующей.
Рабочая таблица содержит строки, полученные на предыдущем шаге. Они используются для рекурсивного обращения к CTE. То есть когда внутри CTE идёт обращение к самому CTE, используются данные именно из рабочей таблицы.

Рекурсия работает до тех пор, пока рабочая таблица не пустая. То есть предыдущий шаг вернул данные, и текущий шаг должен их обработать.
Промежуточная таблица временно хранит данные, полученные на текущем шаге в результате обращения CTE к самому себе (а точнее, к рабочей таблице). В конце шага данные из промежуточной таблицы:
дополняют общую таблицу;
записываются в рабочую таблицу, чтобы использоваться на следующем шаге;
удаляются из самой промежуточной таблицы. В конце шага промежуточная таблица очищается.
Рассмотрим, как СУБД обрабатывает каждый шаг рекурсии в нашем примере. 
Шаг 1. Первый нерекурсивный запрос внутри CTE dev_department получает строку с id = 3 и сохраняет результат в рабочую таблицу и общую таблицу:
Общая таблица содержит одну строку, соответствующую руководителю отдела разработки Соколову Е.В. Рабочая таблица содержит одну строку — ту же самую.
Шаг 2. Проверяет, есть ли данные в рабочей таблице. Данные есть, и тогда выполняется JOIN основной таблицы company_org и рабочей таблицы, и находит строки с parent_id = 3: это строки с id = 6 и id = 7:
Описание иллюстрации — в тексте выше. 
Найденные две строки сохраняются в промежуточную таблицу и добавляются в общую таблицу. В результате сначала получится (середина шага):
Промежуточная таблица содержит две строки — с данными о старшем разработчике и ведущем тестировщике. Общая таблица содержит три строки. Они содержат данные (последовательно): о руководителе отдела разработки, о старшем разработчике и ведущем тестировщике.
А потом содержимое промежуточной таблицы переедет в рабочую таблицу (конец шага):
Общая таблица содержит три строки — с данными о руководителе отдела разработки, старшем разработчике и ведущем тестировщике. Промежуточная таблица пуста. Рабочая таблица содержит данные о старшем разработчике и ведущем тестировщике.
Шаг 3. Рабочая таблица всё ещё не пустая, поэтому рекурсивно повторяется последовательность действий. Снова выполняется JOIN основной таблицы company_org и рабочей таблицы, и находятся строки, у которых parent_id = 6 и parent_id = 7. 
Получаем такую общую и промежуточную таблицы:
Промежуточная таблица содержит пять строк — с данными о двух разработчиках, аналитике и двух тестировщиках. Общая таблица таблица содержит восемь строк — с данными о руководителе отдела, старшем разработчике, ведущем тестировщике, двух разработчиках, аналитике и двух тестировщиках.
Затем результат из промежуточной таблицы попадает в рабочую.
Таким образом, каждая новая итерация рекурсии работает только с результатами предыдущей итерации, не возвращаясь к тому, что уже было найдено.
Шаг 4. Рабочая таблица всё ещё не пустая, поэтому выполняется JOIN основной таблицы company_org и рабочей таблицы. СУБД пытается найти строки, у которых parent_id равен 8, 9, 10, 11 или 12. Но таких строк нет, промежуточная таблица остаётся пустой, рабочая таблица также не заполняется. И поэтому на данном моменте рекурсия завершается.
Результат рекурсивного запроса выводится из общей таблицы. Итог работы запроса — набор строк:
id	parent_id	pos_name	fio
3	1	Руководитель отдела разработки	Соколов Е.В.
6	3	Старший разработчик	Вовченко П.Г.
7	3	Ведущий тестировщик	Семёнов Р.В.
8	6	Разработчик	Коротков И.Д.
9	6	Разработчик	Зимарин Н.Л.
10	6	Аналитик	Аксёнова Н.Д.
11	7	Тестировщик	Борисов М.Ю.
12	7	Тестировщик	Цветкова Л.О.
В этом уроке вы уже познакомились с иерархиями и разобрались, как их обрабатывают рекурсивные запросы. Сейчас вы примерно в середине урока. Если вы чувствуете, что вам нужен перерыв — сделайте его. Например, устройте английское чаепитие. Ждём вас отдохнувшими и свежими.


Вывод результатов рекурсивного запроса
В примере СУБД получала результаты последовательно по уровням иерархии: сначала алгоритм исследовал узлы на одном уровне, затем переходил к узлам следующего уровня. Такой обход иерархии называется поиском в ширину. В результате такого обхода результирующий набор строк сортируется в порядке уровней иерархии. 
Есть и другой способ вывода результата рекурсивного запроса. В нём алгоритм начинается с корневого элемента и спускается максимально по одной ветви, пока не достигнет конечного элемента или пока не будет выполнено определённое условие. Затем алгоритм возвращается на шаг назад и исследует следующую ветвь до конечного элемента, и так далее. Такой обход иерархии называется поиском в глубину. Он выводит те же строки иерархии, но в другом порядке. 
Изобразим схематически иерархию так:
Иерархическая структура. Корневой узел — A, его потомки: B, C, D. Потомки узла B — узлы E и F. Потомки узла D — узлы G и H. У узлов C, E, F, G, H потомков нет.
Тогда поиск в ширину обойдёт узлы в порядке: A - B - C - D - E - F - G - H. 
А поиск в глубину обойдёт узлы так: A - B - E - F - C - D - G - H. 
Посмотрите оба варианта на схеме:
Описание иллюстрации — в тексте выше. 
Оба способа обходят все узлы иерархии, но выводят их в разном порядке.
Чтобы управлять выводом результата рекурсивного запроса, нужно добавить вычисляемый столбец, по которому можно упорядочить результаты.
Посмотрим на нашей задаче. Чтобы алгоритм обходил иерархию «в ширину», в рекурсивный CTE добавим новый столбец level с номером уровня иерархии:

WITH RECURSIVE dev_department AS (
    SELECT 
        id, 
        parent_id, 
        1 as level,    /* Добавлен новый столбец level  */
        pos_name, 
        fio
    FROM company_org
    WHERE id = 3  
    UNION ALL  
    SELECT 
        org.id, 
        org.parent_id, 
        level + 1,    /* Добавлен новый столбец level  */
        org.pos_name, 
        org.fio
    FROM company_org org 
    INNER JOIN dev_department dev ON org.parent_id = dev.id     
)
SELECT * 
FROM dev_department
ORDER BY level;    /* Добавлена сортировка по столбцу level  */ 
И посмотрим на результат работы запроса:
Первая строка — первый (верхний) уровень иерархии — руководитель отдела разработки. Вторая и третья строка — второй уровень иерархии: старший разработчик и ведущий тестировщик. Строки 4–8 — третий уровень иерархии: два разработчика, аналитик и два тестировщика.
Видно, что результаты обхода упорядочены по уровням: от верхнего к нижнему. Каждый уровень иерархии обведён в отдельную рамочку. 
Чтобы алгоритм обходил иерархию в глубину, добавим в CTE столбец full_path, который содержит пройденный путь, а в основном запросе добавим сортировку по этому столбцу. 

WITH RECURSIVE dev_department AS
(
    SELECT id, 
        parent_id, 
        1 AS level, 
        pos_name, 
        fio, 
        fio::TEXT AS full_path    /* Добавлен полный путь к узлу */
    FROM company_org
    WHERE id = 3  
    UNION ALL  
    SELECT org.id, 
        org.parent_id, 
        level + 1, 
        org.pos_name, 
        org.fio, 
        CONCAT(dev.full_path, '-', org.fio) AS full_path    /* "склеиваем" значения 
            пути, полученного до этого, с текущей ФИО */
    FROM company_org org 
    INNER JOIN dev_department dev ON org.parent_id = dev.id
)
SELECT * 
FROM dev_department 
ORDER BY full_path    /* Добавлена сортировка */ 
Результат запроса:
На иллюстрации — результат выполнения кода. Последовательность вывода сотрудников отличается от последовательности, полученной в предыдущем коде.
Видно, что сначала выведены все сотрудники первого подчинённого руководителя отдела разработки, затем все сотрудники его второго подчинённого.



Движение по иерархии в разных направлениях
Когда мы получали список всех сотрудников отдела разработки, мы соединяли основную таблицу и CTE dev_department. Для соединения мы использовали столбцы идентификаторов: id из CTE и parent_id из основной таблицы. Такое соединение позволило нам двигаться по иерархии вниз и вывести всех подчинённых, то есть все дочерние узлы. 
Бывают и обратные задачи — когда для дочернего элемента нужно получить родительские узлы. Например, найти руководителя конкретного сотрудника. В таком случае нужно двигаться по иерархии в противоположном направлении — от дочернего элемента вверх к корневому. 
Для этого в рекурсивной части CTE нужно указать JOIN по столбцам идентификаторов в обратном направлении: parent_id из CTE и id из основной таблицы. Тогда на каждом шаге рекурсии ваш запрос будет выбирать родительский узел для текущего элемента.
Получаем такой шаблон для общего случая:
Если поставить внутри `JOIN` после `ON` условие `main.id=cte.parent_id`, получим движение вверх по иерархии. 
Если поставить внутри `JOIN` после `ON` условие `cte.id=main.parent_id`, получим движение вниз.
Преимущества и недостатки применения рекурсии
У рекурсии в SQL есть важные достоинства: 
Легко написать запрос для обхода иерархической структуры, особенно когда неизвестно количество уровней иерархии. Такие структуры часто сложно обрабатывать с помощью стандартных запросов SQL, и рекурсивные запросы эффективны.
В некоторых ситуациях рекурсивные запросы повышают читаемость кода. Рекурсия избавляет от необходимости использовать сложные соединения, временные таблицы или несколько отдельных запросов.
Однако краткость рекурсивных запросов может затруднить понимание и последующую корректировку запроса. Иногда бывает сложно разобраться, что всё же происходит внутри него.
Чем отличаются таблицы, которые хранят данные об иерархиях, от простых таблиц? Выберите один правильный вариант ответа.


Иерархические таблицы содержат только числовые значения.

В иерархических таблицах каждая запись ссылается на одну главную запись.

Иерархические таблицы имеют столбец, который указывает на родительскую запись в той же таблице.

Простые таблицы не могут хранить иерархическую информацию.
В уроке мы создали таблицу company_org и наполнили её данными. Выполните с помощью DBeaver следующий рекурсивный запрос: 

WITH RECURSIVE subordinates AS (
    SELECT id, parent_id
    FROM company_org
    UNION ALL
    SELECT s.id, co.parent_id
    FROM company_org co
    JOIN subordinates s ON co.id = s.parent_id
)
SELECT co.id, co.fio, COUNT(s.id) AS total
FROM company_org co
LEFT JOIN subordinates s ON co.id = s.parent_id
GROUP BY co.id, co.fio
ORDER BY total DESC
LIMIT 3; 