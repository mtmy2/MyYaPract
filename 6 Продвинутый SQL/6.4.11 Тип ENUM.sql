Пользовательские типы данных. Тип ENUM
Все типы данных, которые вы изучали до этого, называются встроенными, или базовыми. Помимо них разработчик может создать свой тип — пользовательский.
В базе данных Taxi Online хранится информация об автомобилях, которые используют для работы в такси. Данные хранятся в таблице cars:
guid	gos_num	engine
Поскольку данные об автомобилях, как и данные о водителях, поступают от различных источников, в качестве первичного ключа выбран столбец guid с типом uuid.
Государственный номер автомобиля хранится в поле gos_num. Он состоит из девяти знаков, поэтому оптимально для этого поля будет использовать тип char(9).
В поле engine хранится информация о типе двигателя автомобиля. Двигатели бывают:
бензиновыми,
дизельными,
электрическими,
гибридными.
Можно использовать для хранения этой информации тип text. Однако набор значений этого поля конечен. Вместо text было бы здорово создать свой собственный тип данных, который гарантирует, что в поле попадут только корректные данные из списка и не попадёт ничего лишнего. В PostgreSQL такая возможность есть — это пользовательские типы данных.
Какими бывают пользовательские типы данных
Есть четыре вида пользовательских типов:
Перечисления — это тип enum, с ним вы познакомитесь в этом уроке.
Составные типы — задаются пользователем в виде набора полей с указанием имени и типа каждого поля. Им будет посвящён следующий урок.
Базовые типы — реализуются не на SQL и требуют особых навыков разработки. Обычно они создаются на языке С. После создания существуют в системе наравне со встроенными типами. Ошибочное определение таких типов может вызвать сбой сервера БД. Вы не будете рассматривать базовые типы в этом курсе, но можете ознакомиться с ними самостоятельно в документации.
Диапазоны — задают диапазоны. Это может быть собственный пользовательский диапазон или диапазон одного из встроенных типов:
int4range — диапазон значений integer.
int8range — диапазон значений bigint.
numrange — диапазон значений numeric.
tsrange — диапазон значений timestamp without time zone.
tstzrange — диапазон значений timestamp with time zone.
daterange — диапазон значений date.
Эти типы также не входят в программу нашего курса, но хорошо освещены в документации.
Иллюстрация текста выше

Виды пользовательских типов данных
Пользовательские типы существуют на уровне схемы БД и должны иметь уникальное имя в рамках схемы.
Все пользовательские типы создаются командой CREATE TYPE, синтаксис которой немного отличается в зависимости от вида создаваемого типа.
Тип enum
enum — перечисляемый тип. Это значит, что у данных, которые вы будете описывать этим типом, есть некий конечный, заранее известный вам набор значений, который вы можете перечислить. Как в примере с автомобилями, где тип двигателя может принимать одно из заранее определённых значений.
enum создают такой конструкцией:

CREATE TYPE <имя_схемы>.<имя_типа> AS ENUM (<список_значений_через_запятую>); 
Тип создаётся в одной из существующих схем. Если имя схемы не указано, то по умолчанию новый тип создастся в схеме public.
Создайте тип engine_type в схеме taxi:

CREATE TYPE taxi.engine_type AS ENUM 
    ('бензиновый', 'дизельный', 'электрический', 'гибридный'); 
Информация о нём появится в Навигаторе в разделе с типами данных Data types схемы taxi.
Раздел Data types схемы `taxi`. В него добавился тип `engine_type`.
Теперь можно создать таблицу cars, используя этот тип для одного из столбцов:

CREATE TABLE taxi.cars (
    guid uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    gos_num char(9),
    engine taxi.engine_type
); 
При создании таблицы имя типа нужно указывать совместно с именем схемы, в которой он находится. Если имя схемы не указано, то по умолчанию СУБД будет искать тип в схеме public. Если его там нет, то запрос вернет ошибку.
Таблица создана без ошибок. Добавьте в неё пару строк с корректными значениями engine:

INSERT INTO taxi.cars (gos_num, engine) 
VALUES 
    ('A111AA111', 'электрический'),
    ('B222BB222', 'бензиновый'); 
Значения вставились успешно. Теперь попробуйте вставить некорректные данные и посмотрите, что получится:

INSERT INTO taxi.cars (gos_num, engine) VALUES ('C333CC333', 'газотурбинный'); 
Появилось сообщение об ошибке:
ERROR:  invalid input value for enum engine_type: "газотурбинный" 
Оно сообщает, что значение «газотурбинный» некорректно для enum-типа engine_type.
Теперь попробуйте такой вариант:

INSERT INTO taxi.cars (gos_num, engine) VALUES ('E444EE444', 'Электрический') 
Та же ошибка — потому что для типа enum «электрический», «Электрический» и «ЭЛЕКТРИЧЕСКИЙ» — три разных значения.
Массивы enum
Вернитесь к таблице drivers. Сейчас она выглядит так:
guid	driver_name	driver_license	depot_id	worksheet_jsonb	worksheet_json
Помимо номера водительского удостоверения, полезно было бы хранить информацию о категориях прав водителя в поле category. Вот список всех возможных категорий водительского удостоверения:

('M', 'A', 'A1', 'B', 'BE', 'B1', 'C', 'CE', 'C1', 
'C1E', 'D', 'DE', 'D1', 'D1E', 'F', 'Tm', 'Tb') 
Однако использовать для поля category тип enum не получится, потому что у одного водителя может быть сразу несколько категорий.
При создании пользовательского типа данных автоматически создаётся и массив для этого типа, например: 

taxi.engine_type[] 
Останется лишь создать тип для хранения категорий прав:

CREATE TYPE taxi.license_category AS ENUM 
    ('M', 'A', 'A1', 'B', 'BE', 'B1', 'C', 'CE', 'C1', 
    'C1E', 'D', 'DE', 'D1', 'D1E', 'F', 'Tm', 'Tb'); 
и добавить в таблицу drivers новое поле:

ALTER TABLE taxi.drivers ADD COLUMN category taxi.license_category[]; 
Также можно использовать альтернативный синтаксис при объявлении типа поля. В этом варианте массив пользовательских типов называется так же, как сам тип, но со знаком нижнего подчёркивания в начале, например:

ALTER TABLE taxi.drivers ADD COLUMN category taxi._license_category; 
Для встроенных типов данных нельзя обозначать массив нижним подчёркиванием. Запись _integer вернёт ошибку.
Добавьте три категории водителю Колесову:

UPDATE taxi.drivers SET category = '{A, B, C}' 
WHERE driver_name = 'Колесов Игорь Витальевич' 
Строка успешно обновилась.
Сравнение значений пользовательских типов
Для каждого нового пользовательского типа автоматически можно применить операторы сравнения. 
При этом считается, что значение, стоящее в начале списка при создании типа, — минимальное, а в конце — максимальное.
Иллюстрация текста выше
В примере с типами двигателей сравнение не имеет физического смысла, а вот для категорий водительских удостоверений сравнение может пригодиться. Например, автомобиль, которым можно управлять с категорией C, больше автомобиля, которым можно управлять с категорией B:

SELECT 'C'::taxi.license_category > 'B'::taxi.license_category; 
Результат такого сравнения — true.
Используйте возможности оператора сравнения, когда в вашем перечислении можно расставить элементы в порядке возрастания приоритета или размера.
При этом сравнение двух разных типов enum бессмысленно и всегда вызывает ошибку:

SELECT 'C'::taxi.license_category > 'электрический'::taxi.engine_type; 
ERROR:  operator does not exist: license_category > engine_type 
Ошибка говорит, что вы пытаетесь сравнить два совершенно разных типа, а это недопустимо.
Удаление типа данных
Удалить тип данных можно также, как и другой объект базы данных, используя оператор DROP.
Удалите тип данных engine_type:

DROP TYPE taxi.engine_type; 
Запрос вернёт ошибку, так как в существующей таблице cars есть поле этого типа. Если бы тип нигде не использовался, проблем бы не возникло. 
Есть другое решение. Если вам всё-таки нужно удалить тип данных, то можно воспользоваться командой DROP CASCADE: 

DROP TYPE taxi.license_category CASCADE; 
В этом случае тип данных будет удалён вместе со всеми колонками этого типа. Будьте внимательны при использовании каскадного удаления типа, чтобы не потерять нужные данные.
Выберите все верные утверждения.


Правильный ответ
В PostgreSQL есть возможность создавать типы данных на языке C.
Действительно, этот язык можно использовать для создания базовых типов.

Пользовательские типы данных должны иметь уникальное имя в пределах базы данных.
Пользовательские типы существуют внутри схемы БД и должны иметь уникальное имя внутри неё.

Некорректное создание типа enum может привести к неполадкам в работе сервера БД.
На работу сервера БД могут повлиять только базовые типы.

Правильный ответ
Тип enum удобно использовать для дискретных значений, точное количество которых определено.
Количество возможных значений типа enum должно быть определено при его создании.

Неправильный ответ
Существует два диапазонных типа данных — INTRANGE и TEXTRANGE.
Существует шесть диапазонных типов и возможность создавать новые.
Выберите единственный верный вариант синтаксиса создания типа enum.



CREATE TYPE taxi.semaphore AS ('красный', 'жёлтый', 'зелёный'); 
При создании перечисляемого типа нужно обязательно указать слово enum.

Правильный ответ

CREATE TYPE taxi.semaphore AS ENUM ('красный', 'жёлтый', 'зелёный'); 
Это правильный синтаксис создания типа enum.


CREATE TYPE ENUM taxi.semaphore AS ('красный', 'жёлтый', 'зелёный'); 
Слово enum должно стоять после AS.


CREATE TYPE taxi.semaphore ('красный', 'жёлтый', 'зелёный'); 
При создании типа обязательно нужно указать AS enum.
В системе есть тип данных semaphore, описанный в предыдущем квизе. Какой из этих запросов даст ошибку при выполнении?


Правильный ответ

CREATE TABLE semaphores (
    id integer,
    semaphore_color semaphore
) 
Тип данных semaphore был создан в схеме taxi, в схеме public его нет. Запрос вызовет ошибку.

Правильный ответ

CREATE TABLE semaphores (
    id integer,
    semaphore_color taxi.semaphore_
) 
Знак подчёркивания после названия типа вызовет ошибку.


CREATE TABLE semaphores (
    id integer,
    semaphore_color taxi._semaphore
) 
Это верный вариант синтаксиса для создания таблицы с полем-массивом типа semaphore.

Неправильный ответ

CREATE TABLE semaphores (
    id integer,
    semaphore_color taxi.semaphore[]
) 
Это верный вариант синтаксиса для создания таблицы с полем-массивом типа semaphore.
Есть два типа enum:

CREATE TYPE semaphore AS ENUM ('красный', 'жёлтый', 'зелёный');
CREATE TYPE flavor AS ENUM ('кислый', 'сладкий', 'горький'); 
Выберите все запросы, которые вернут true.



SELECT 'зелёный' > 'красный' 
Так как у этих значений не указан тип, они сравниваются как константы базового строкового типа данных. ‘зелёный’ раньше по алфавиту, чем ‘красный’, то есть меньше. Запрос вернёт false.

Правильный ответ

SELECT 'зелёный'::semaphore > 'красный'::semaphore 
Значение 'зелёный' при создании типа стояло после 'красный', поэтому будет считаться, что 'зелёный' больше.


SELECT 'кислый'::flavor > 'красный'::semaphore 
Сравнение двух разных enum приведёт к ошибке.

Тоже правильный ответ

SELECT 'кислый' < 'красный' 
Так как у этих значений не указан тип, они сравниваются как строковые константы. ‘кислый’ раньше по алфавиту, чем ‘красный’. Запрос вернёт true.

