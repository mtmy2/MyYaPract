Пример использования материализованного представления
В этом уроке вы посмотрите, как можно применять материализованное представление для оптимизации расчётов. Для этого вы создадите упрощённую модель банка.
Банковская деятельность — сложная комплексная сфера, но в примере мы намеренно упростим все процессы и саму базу данных в учебных целях. Ведь нам важно рассмотреть технику использования материализованных представлений, а не погрузиться в мир денег, золотых слитков и кредитов. 
Допустим, вам нужно создать максимально простую БД банка из двух таблиц:
clients — содержит данные о клиентах: ФИО и телефон,
payments — содержит данные о движении денег по счёту клиента: сумму платежа, дату и время платежа и id клиента.
Для простоты будем считать, что:
Счёт у клиента всегда один — поэтому вы не будете создавать таблицу счетов клиентов accounts. В реальных банках у клиентов может быть множество счетов и такая таблица была бы обязательной.
Счёт не учитывает бухгалтерские особенности банковской деятельности — поэтому дебетовые и кредитные движения средств вы будете отражать на одном-единственном счёте по каждому клиенту.
Итак, у вас есть клиенты и какие-то движения средств по единственному счёту каждого клиента:
Если сумма положительная — деньги внесли на счёт клиенту.
Если сумма отрицательная — деньги сняли со счёта клиента.
Скрипт ниже создаёт нужные таблицы и наполняет их синтетическими данными. Изучите и выполните его.

-- Удалите таблицы, если они уже существуют
DROP TABLE IF EXISTS clients CASCADE;
DROP TABLE IF EXISTS payments CASCADE;

-- Создайте таблицу clients
CREATE TABLE IF NOT EXISTS clients (
    id SERIAL PRIMARY KEY,
    fio CHARACTER VARYING,
    phone CHARACTER VARYING
);

-- Создайте таблицу payments
CREATE TABLE IF NOT EXISTS payments (
    id SERIAL PRIMARY KEY,
    client_id INTEGER REFERENCES clients(id),
    amount NUMERIC(18,2),
    created_at TIMESTAMPTZ
);

-- Вставьте 1000 синтетических клиентов в таблицу clients
INSERT INTO clients (fio, phone)
SELECT
    'ФИО ' || generate_series AS fio,
    'Телефон ' || generate_series AS phone
FROM generate_series(1, 1000);

-- Вставьте синтетические записи в таблицу payments
INSERT INTO payments (client_id, amount, created_at)
    SELECT
        client_id,
        amount,
        created_at
    FROM
        (SELECT
             -- Возьмите рандомный id клиентов от 1 до 1000
             1 + (RANDOM() * 999)::INTEGER AS client_id,
             -- Возьмите рандомные суммы  от -50000 до +50000
             -50000 + (RANDOM() * 100000)::NUMERIC(18,2) AS amount,
             -- Возьмите рандомные даты за прошедший год
             CURRENT_TIMESTAMP - '1 year'::interval * random() AS created_at
         FROM generate_series(1, 20000)
        ) ra
     ORDER BY ra.created_at; 
Функция RANDOM() возвращает случайное число в диапазоне 
0
≤
x
≤
1
0≤x≤1.
Если эту функцию использовать в выражении:
1 + (RANDOM() * 999)::INTEGER — результатом выражения будет случайное число типа integer от 1 до 1000.
-50000 + (RANDOM()*100000)::NUMERIC(18,2) — результатом будет любое число от -50 000 до 50 000 (невключительно) типа NUMERIC(18,2).
CURRENT_TIMESTAMP - '1 year'::interval * RANDOM() — результатом будут случайные дата и время в интервале от даты год назад до текущего момента.
Так как данные в таблицу вы вставляете синтетические и рандомные, то данные в таблицах каждый раз будут разные. 
Посмотрите движение денег на счёте для клиента, с client_id = 1.
Выполните запрос:

SELECT
    *, 
    /*используя оконную функцию и расчёт кумулятивных значений,
     добавим поле с остатком на счёте после каждой операции*/
    SUM(amount) OVER (
        PARTITION BY client_id ORDER BY created_at
    ) AS account_balance 
FROM payments
WHERE client_id = 1
ORDER BY created_at; 
Результат будет примерно таким. При этом количество строк и суммы могут сильно отличаться от представленных:
id	client_id	amount	created_at	account_balance
1629	1	-47884,78	2022-08-09 13:20:20.000 + 0500	-47884,78
3119	1	49490,76	2022-09-05 21:14:47.000 + 0500	1605,98
6402	1	21863,39	2022-11-05 17:57:37.000 + 0500	23469,37
6892	1	34626,92	2022-11-14 15:52:19.000 + 0500	58096,29
7374	1	48426,71	2022-11-22 23:24:11.000 + 0500	106523
10548	1	35918,97	2023-01-20 16:29:15.000 + 0500	142441,97
13251	1	-20920,63	2023-03-10 20:59:29.000 + 0500	121521,34
13388	1	-6749,78	2023-03-13 16:35:25.000 + 0500	114771,56
13885	1	34747,42	2023-03-22 20:35:43.000 + 0500	149518,98
16156	1	23095,58	2023-05-02 19:20:11.000 + 0500	172614,56
16716	1	-2126,95	2023-05-12 19:10:45.000 + 0500	170487,61
16724	1	38441,7	2023-05-12 21:31:51.000 + 0500	208929,31
17392	1	44643,1	2023-05-24 12:00:21.000 + 0500	253572,41
18710	1	36210,47	2023-06-16 19:11:42.000 + 0500	289782,88
На счёт клиента с client_id = 1 вносились средства — положительные суммы и снимались средства — отрицательные суммы. В итоге остаток на счёте клиента = 289 782.88 рублям.
Таблицы заполнены рандомными синтетическими данными: среди клиентов должны быть пользователи и с положительным остатком на счёте, и с отрицательным.
Создайте материализованное представление на основе таблиц clients и payments. Это представление отражает остатки на счетах клиентов на текущий момент.

CREATE MATERIALIZED VIEW v_client_account_balance AS
    SELECT 
        client_id, 
        SUM(amount) AS account_balance
    FROM payments
    GROUP BY client_id
    ORDER BY client_id; 
Днём деньги постоянно перемещаются: клиенты кладут средства на счёт и тратят их. Ночью запускается программа-обработчик, которая обновляет результаты материализованного представления v_client_account_balance командой REFRESH и сохраняет результаты этого запроса на диск.

REFRESH MATERIALIZED VIEW v_client_account_balance; 
На следующий рабочий день приходят сотрудники разных отделов банка, и всем им нужны данные:
Кредитный отдел запрашивает список всех клиентов, у которых по состоянию на начало дня задолженность более 300 тыс. рублей.

      SELECT
          cl.*,
          cab.account_balance
      FROM clients AS cl
      INNER JOIN v_client_account_balance AS cab ON (cl.id = cab.client_id)
      WHERE cab.account_balance < -300000;
       
Отдел новых продуктов хочет отобрать клиентов, у которых по состоянию на начало дня на счёте более 300 тыс. рублей.

      SELECT
          cl.*,
          cab.account_balance
      FROM clients AS cl
      INNER JOIN v_client_account_balance AS cab ON (cl.id = cab.client_id)
      WHERE cab.account_balance > 300000;
       
Отдел отчётности хочет посчитать баланс банка: узнать, сколько средств на счетах всех клиентов и сколько денег взято в кредит по состоянию на начало дня

      SELECT
          SUM(CASE WHEN account_balance > 0 THEN account_balance END) AS DEBIT_BALANCE, 
          SUM(CASE WHEN account_balance < 0 THEN account_balance END) AS CREDIT_BALANCE,
          SUM(account_balance) AS BALANCE
      FROM v_client_account_balance;
       
В каждом случае мы обращаемся не к таблице платежей payments, а к материализованному представлению.
Если бы вы создали v_client_account_balance как обычное представление, а не материализованное, появились бы проблемы: 
Результаты на одни и те же запросы каждый раз расходились бы. Кроме того, расходились бы данные у разных сотрудников разных отделов, потому что движение средств не останавливалось бы и клиенты банка вносили бы деньги или списывали бы деньги со счетов постоянно. Вы бы обращались всё время к постоянно меняющимся таблицам и получали постоянно новые результаты. В варианте с материализованным представлением отделы банка располагают результатами по остаткам на вечер предыдущего дня, и чаще всего этого достаточно для выполнения задач.
Вы бы выполняли запросы и каждый раз считали бы по всем клиентам их остатки. Если в банке 1000 клиентов, то такой подход мог и подойти, но, если в банке более 100 млн клиентов, ни один сервер не смог бы работать в нормальном режиме — он бы просто завис.

