Расчёт кумулятивных значений
Кумулятивные значения рассчитывают с накоплением. Простой пример — счёт. Оценивая количество, вы называете числа: один, два, три и т. д. Каждое следующее число вы получаете, прибавляя единицу. Это и есть накопление.
Приведём ещё один пример. Школьнику Феде дают деньги на карманные расходы. Он их не тратит, а откладывает, чтобы купить игровую приставку. Каждый день Федя записывает, сколько денег получил и сколько стало в копилке.
День	Сколько получил	Сколько в копилке
Понедельник	100	100
Вторник	120	220
Среда	140	360
Четверг	110	470
Пятница	80	550
Порассуждаем в логике SQL: рассчитать деньги в копилке можно с помощью агрегирующей функции SUM, применив её к каждой ячейке поля Сколько получил. Поле Сколько в копилке хранит кумулятивные, или накопленные, значения — сумма в нём накапливается со временем. 
Считать с накоплением можно не только карманные расходы — такие расчёты часто встречаются при анализе бизнес-процессов, например, кумулятивный расчёт выручки или затрат за определённый период. Расчёты с накоплением помогают отследить динамику роста общего количества проданного товара по дням или динамику набора пользователей при проведении A/B-теста.
Вернёмся к оконным функциям. Оператор ORDER BY в выражении OVER позволяет не только сортировать значения. Если сочетать его с агрегирующими функциями, можно производить вычисления кумулятивно. 

Сумма с накоплением
Покажем, как рассчитать сумму с накоплением в SQL. Рассчитаем сумму затрат на рекламу для канала Yandex с накоплением.
Для примера воспользуемся схемой online_store магазина «Сила — в окнах» и посчитаем кумулятивную стоимость привлечения клиентов по каналу Yandex.
Описание схемы online-store онлайн-магазина «Сила — в окнах»


SELECT *,
    SUM(costs) OVER (ORDER BY dt) AS costs_cum
FROM online_store.costs
WHERE channel = 'Yandex'; 

Запрос отсортировал данные в поле dt по возрастанию — это поле указано после оператора ORDER BY в выражении OVER. Сумма с накоплением считается так: к значению предыдущей записи прибавляется значение текущей — и так с каждой записью до конца таблицы.
Сравните с результатом запроса без фильтра channel = 'Yandex'. В поле dt, по которому сортируют данные, встречается несколько одинаковых значений. В таких записях значения costs будут складываться. При этом сумма будет также рассчитана кумулятивно. 

SELECT *,
    SUM(costs) OVER (ORDER BY dt) AS costs_cum
FROM online_store.costs; 

dt	channel	costs	costs_cum
2020-06-14	AnotherSource	1826	2674
2020-06-14	Yandex	848	2674
2020-06-15	AnotherSource	1443	4851.75
2020-06-15	Yandex	734.75	4851.75
2020-06-16	AnotherSource	1508	7193
2020-06-16	Yandex	833.25	7193

Сумму с накоплением можно рассчитать и для каждого окна отдельно. Для этого нужно добавить оператор PARTITION BY и указать нужное поле. Этот запрос рассчитает общее время сессий с накоплением для каждого пользователя:

SELECT 
    user_id,
    session_duration,
    session_start,
    SUM(session_duration) OVER (PARTITION BY user_id ORDER BY session_start)
FROM online_store.sessions; 

user_id	session_duration	session_start	sum
10964006	18	2020-06-25 04:50:17	18
10964006	9	2020-06-26 04:00:27	27
10964006	21	2020-06-27 04:21:06	48
12358165	7	2020-06-23 23:16:24	7
12358165	1	2020-06-24 11:01:14	8


Для расчёта кумулятивных значений по разделам можно использовать и функцию COUNT. Запрос ниже будет считать накопленное количество пользователей по каждой дате. Можно сказать, что для каждого пользователя оконная функция посчитает его порядковый номер в этот день. Чтобы ограничить выборку, будем считать порядковые номера только для пользователей, у которых в user_id не более 9 цифр.

SELECT 
    user_id,
    dt,
    COUNT(*) OVER (PARTITION BY dt ORDER BY user_id)
FROM online_store.profiles
WHERE user_id < 1000000000; 

user_id	dt	count
421605341	2020-06-15	1
51602715	2020-06-16	1
59432616	2020-06-16	2
498882833	2020-06-16	3
801838656	2020-06-16	4
58494719	2020-06-17	1
307741145	2020-06-17	2
411325485	2020-06-17	3
659613014	2020-06-17	4


Обратите внимание, что выше приведена только часть от всей результирующей выборки.
Функции MIN, MAX, AVG тоже используют для расчёта кумулятивных значений. Если сочетать эти функции с оператором ORDER BY в выражении OVER, при каждом новом расчёте минимума, максимума или среднего будет учитываться текущая запись вместе с предыдущими. 
Например, с минимумом получим накопленное минимальное значение на каждый день:

SELECT *,
    MIN(costs) OVER (ORDER BY dt) AS costs_cum
FROM online_store.costs
WHERE channel = 'Yandex'; 


dt	channel	costs	costs_cum
2020-06-14	Yandex	848	848
2020-06-15	Yandex	734.75	734.75
2020-06-16	Yandex	833.25	734.75
2020-06-17	Yandex	1065.08	734.75
2020-06-18	Yandex	1035.38	734.75
2020-06-19	Yandex	1014.83	734.75
2020-06-20	Yandex	840.263	734.75
2020-06-21	Yandex	764.925	734.75
2020-06-22	Yandex	703.475	703.475
2020-06-23	Yandex	830.775	703.475

Поскольку 14 июня — это первый из выведенных дней, то и кумулятивная минимальная стоимость привлечения равна тратам за этот день. Стоимость привлечения за 15 июня меньше, чем за 14, поэтому накопленное значение равно первому показателю, минимальному из двух. 
Смотрим дальше: costs за 16 июня больше, чем за 15 июня, поэтому накопленное так и остается равным 734, 75 — минимальному значению за 3 дня.

В случае с функцией MAX логика выбора кумулятивного значения аналогична MIN: максимальным кумулятивным значением за прошедший период будет максимальное значение за этот период. 

SELECT *,
    MAX(costs) OVER (ORDER BY dt) AS costs_cum
FROM online_store.costs
WHERE channel = 'Yandex'; 
dt	channel	costs	costs_cum
2020-06-14	Yandex	848	848
2020-06-15	Yandex	734.75	848
2020-06-16	Yandex	833.25	848
2020-06-17	Yandex	1065.08	1065.08
2020-06-18	Yandex	1035.38	1065.08


При расчёте среднего накопленного значения за период результатом оконной функции будет среднее между прошедшими промежутками.
Например, средняя стоимость привлечения за первый день равна сумме привлечения за этот день, за второй день — среднему между первым и вторым днем, за третий день — среднему за первые три дня, и так далее.

SELECT *,
    AVG(costs) OVER (ORDER BY dt) AS costs_cum
FROM online_store.costs
WHERE channel = 'Yandex'; 
dt	channel	costs	costs_cum
2020-06-14	Yandex	848	848
2020-06-15	Yandex	734.75	791.375
2020-06-16	Yandex	833.25	805.333
2020-06-17	Yandex	1065.08	870.269
2020-06-18	Yandex	1035.38	903.29