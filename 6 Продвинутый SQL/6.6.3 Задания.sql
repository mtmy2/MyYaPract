Задания
В этом самостоятельном проекте вы построите дополнительные таблицы с продвинутыми типами данных и выполните семь заданий: поработаете с транзакциями и блокировками, создадите представления и напишете несколько аналитических запросов, используя оконные функции и подзапросы.
В заданиях есть подсказки. Попробуйте сначала справиться без них — в подсказках только один из нескольких возможных вариантов решения. Возможно, ваше решение будет другим — и это здорово! Если задание никак не поддаётся — заглядывайте в подсказку.
Названия полей в таблицах, представлениях и материализованных представлениях должны быть на английском языке — помните о принципах наименования объектов. Правильные названия полей облегчают поддержку вашей БД и повышают читабельность кода.
Разверните базу из дампа и выполните проект в два этапа.
dump-gastrohub.sql
dump-gastrohub-text.zip
Описание данных для проекта Gastro Hub

Схемы
Схема	Описание схемы
raw_data	Хранит необработанные данные. В дампе будет информация по продажам и меню ресторанов.
Таблицы
raw_data.sales — необработанные данные о продажах
Поле	Описание поля	Тип поля
report_date	Дата	date
cafe_name	Название заведения	character varying
type	Тип заведения: бар, ресторан, кофейня, пиццерия	character varying
avg_check	Средний чек за день	numeric(6, 2)
manager	Ф. И. О менеджера заведения	character varying
manager_phone	Телефон менеджера заведения	character varying
raw_data.menu — необработанные данные о меню заведений
Поле	Описание поля	Тип поля
cafe_name	Название заведения	character varying
menu	Меню	jsonb
Этап 1. Создание дополнительных таблиц
Сперва создайте схему для данных GastroHub, таблицы в ней и заполните их данными.
Вот пошаговая инструкция:
Шаг 1. Создайте enum cafe.restaurant_type с типом заведения coffee_shop, restaurant, bar, pizzeria. 
Шаг 2. Создайте таблицу cafe.restaurants с информацией о ресторанах. В качестве первичного ключа используйте случайно сгенерированный uuid. Таблица хранит: restaurant_uuid, название заведения, тип заведения, который вы создали на первом шаге, и меню.
Шаг 3. Создайте таблицу cafe.managers с информацией о менеджерах. В качестве первичного ключа используйте случайно сгенерированный uuid. Таблица хранит: manager_uuid, имя менеджера и его телефон.
Шаг 4. Создайте таблицу cafe.restaurant_manager_work_dates. Таблица хранит: restaurant_uuid, manager_uuid, дату начала работы в ресторане и дату окончания работы в ресторане (придумайте названия этим полям). Задайте составной первичный ключ из двух полей: restaurant_uuid и manager_uuid. Работа менеджера в ресторане от даты начала до даты окончания — единый период, без перерывов.
Подсказка

Отберите uuid менеджера из таблицы с менеджерами и uuid ресторана из таблицы с ресторанами. Далее отберите минимальное и максимальное значение report_date из raw_data.sales. Сгруппируйте по uuid ресторана и uuid менеджера.
Шаг 5. Создайте таблицу cafe.sales со столбцами: date, restaurant_uuid, avg_check. Задайте составной первичный ключ из даты и uuid ресторана.
Шаг 6. Наполните все созданные таблицы данными, которые хранятся в дампе.
Этап 2. Создание представлений и написание аналитических запросов
Дополнительные таблицы готовы, теперь — пора представлений и запросов.
Задание 1
Чтобы выдать премию менеджерам, нужно понять, у каких заведений самый высокий средний чек. Создайте представление, которое покажет топ-3 заведения внутри каждого типа заведений по среднему чеку за все даты. Столбец со средним чеком округлите до второго знака после запятой.
Вот формат итоговой таблицы (числа и названия — для наглядности, это не ответы):
Название заведения	Тип заведения	Средний чек
Заведение 1	Бар	1500
Заведение 2	Бар	1400
Заведение 3	Бар	1300
Заведение 4	Пиццерия	1700
Заведение 5	Пиццерия	1500
Заведение 5	Пиццерия	1300
…	…	…
Подсказка

Чтобы посчитать средние продажи по каждому заведению, создайте CTE, применив функцию AVG. Чтобы получить названия и типы заведений, присоедините CTE к таблице ресторанов. Чтобы ранжировать заведения по средним продажам, используйте функцию ROW_NUMBER() с разбиением по типу заведения и включите в итоговый запрос только три наиболее успешных заведения каждого типа.
Задание 2
Создайте материализованное представление, которое покажет, как изменяется средний чек для каждого заведения от года к году за все года за исключением 2023 года. Все столбцы со средним чеком округлите до второго знака после запятой.
Вот формат материализованного представления, числа и названия — для наглядности:
Год	Название заведения	Тип заведения	Средний чек в текущем году (относительно значения в поле Год)	Средний чек в предыдущем году (относительно значения в поле Год)	Изменение среднего чека в %
2017	Заведение 1	Кофейня	655.25	[null]	[null]
2018	Заведение 1	Кофейня	656.22	655.25	0.15
…	Заведение 1	Кофейня	…	…	…
2022	Заведение 1	Кофейня	…	…	…
2017	Заведение 2	Пиццерия	688.22	[null]	[null]
2018	Заведение 2	Пиццерия	655.12	688.22	-5.05
2019	Заведение 2	Пиццерия	666.46	655.12	1.7.
…	…	…	…	…	…
2022	Заведение 2	Пиццерия	…	…	…
Подсказка

Примените функции EXTRACT и AVG, чтобы создать подзапрос, в котором посчитается средний чек для каждого заведения за каждый год, исключая 2023. Присоедините этот подзапрос к таблице cafe.restaurants — получите названия и типы заведений. В итоговом запросе используйте функцию LAG, разбитую по названию заведения и упорядоченную по году, чтобы получить продажи за предыдущий год. И наконец, вычислите процентное изменение относительно анализируемого года.
Задание 3
Найдите топ-3 заведения, где чаще всего менялся менеджер за весь период.
Вот формат итоговой таблицы, числа и названия — для наглядности:
Название заведения	Сколько раз менялся менеджер
Заведение 1	6
Заведение 2	5
Заведение 3	5
Задание 4
Найдите пиццерию с самым большим количеством пицц в меню. Если таких пиццерий несколько, выведите все.
Вот формат итоговой таблицы, числа и названия — для наглядности:
Название заведения	Количество пицц в меню
Заведение 1	10
Заведение 2	10
Заведение 3	10
Подсказка

Начните с вложенного подзапроса, чтобы извлечь названия пиццерии и меню пицц из таблицы cafe.restaurants в виде json-объекта. Затем примените функцию json_each_text, чтобы преобразовать этот объект в строки, представляющие названия блюд. Сгруппируйте результат по названию пиццерии и используйте функцию COUNT, чтобы посчитать количество блюд в каждом заведении. Примените функцию DENSE_RANK() для ранжирования пиццерий по количеству блюд в порядке убывания. В итоговом запросе выберите только те пиццерии, которые занимают первое место по количеству блюд.
Задание 5
Найдите самую дорогую пиццу для каждой пиццерии.
Вот формат итоговой таблицы, числа и названия — для наглядности:
Название заведения	Тип блюда	Название пиццы	Цена
Заведение 1	Пицца	Маргарита	689
Заведение 2	Пицца	Диавола	566
Заведение 3	Пицца	Четыре сезона	455
Подсказка

Создайте CTE menu_cte, чтобы извлечь названия пиццерии, тип блюда — 'Пицца', названия пицц и их цены из json-объекта menu в таблице cafe.restaurants. Используйте функцию json_each_text, чтобы получить ключи и значения, и приведите значения к целому типу.
Создайте второй CTE menu_with_rank. В нём используйте функцию ROW_NUMBER(), разбитую по названию заведения и упорядоченную по цене блюда в порядке убывания. Это позволит вам ранжировать блюда в каждой пиццерии по цене.
В итоговом запросе выберите названия пиццерии, тип блюда, названия блюд и их цены из menu_with_rank, где ранг цены равен 1. Упорядочьте результат по названию пиццерии в порядке возрастания, чтобы получить самое дорогое блюдо 'Пицца' в каждом заведении.
Задание 6
В Gastro Hub решили проверить новую продуктовую гипотезу и поднять цены на капучино. Маркетологи компании собрали совещание, чтобы обсудить, на сколько стоит поднять цены. В это время для отчётности использовать старые цены нельзя. После обсуждения решили увеличить цены на капучино на 20%.
Обновите данные по ценам так, чтобы до завершения обновления никто не вносил других изменений в цены этих заведений. В заведениях, где цены не меняются, данные о меню должны остаться в полном доступе.
Поясните принятое решение в комментариях к скрипту.
Подсказка

Заблокируйте обновляемые строки внутри активной транзакции и выполните в ней запрос на обновление данных.
Подберите тип блокировки строк, который исключит изменение заблокированных строк.
В запросе на обновление рассчитайте новые цены в отдельном CTE, а затем обновите данные, используя UPDATE для связанных таблиц.
Задание 7
Руководство GastroHub приняло решение сделать единый номер телефонов для всех менеджеров. Новый номер — 8-800-2500-***, где порядковый номер менеджера выставляется по алфавиту, начиная с номера 100. Старый и новый номер нужно будет хранить в массиве, где первый элемент массива — новый номер, а второй — старый.
Во время проведения этих изменений таблица managers должна быть недоступна для изменений со стороны других пользователей, но доступна для чтения.
Поясните решение в комментариях к скрипту.
Подсказка

Откройте транзакцию и заблокируйте таблицу так, чтобы она была недоступна для изменений.
Создайте поле для массива номеров телефонов.
Рассчитайте порядковый номер менеджера по алфавиту с помощью ROW_NUMBER() и определите новый номер телефона, используя CONCAT.
Добавьте в новое поле массив с новым и старым номером.
Удалите старое поле с телефоном.
Зафиксируйте изменения и снимите блокировку с таблицы.
Как оформить решение
Как и в прошлых спринтах сдавать работу вы будете через GitHub. В репозитории уже созданы файлы. Вам необходимо добавить в них своё решение, в каждый файл — определённую часть работы:
DDL.sql — запросы на создание схемы cafe и объектов в ней в нужном порядке.
INSERT.sql — запросы на заполнение таблиц данными из таблиц схемы raw_data,
файлы от task_1.sql до task_7.sql — запросы для заданий в порядке их выполнения,
comments.txt — вопросы ревьюеру или другие комментарии по проекту.
Внутри каждого SQL-файла разделите запросы с помощью ‘;’.
Вам предстоит изучить данные GastroHub вдоль и поперёк. Удачи!