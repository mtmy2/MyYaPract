Общие табличные выражения (СТЕ)
Использовать подзапросы — хорошее решение, но зачастую у них очень громоздкий вид. Что будет, если в одном запросе указать несколько подзапросов: пять, шесть и более? Легко запутаться — нужно искать выход.
Решить проблему могут общие табличные выражения, или CTE (от англ. common table expressions). 
Они помогают декомпозировать решение задачи, а также структурировать подзапросы: то есть выделять каждый из них отдельно и выносить за пределы основного кода. 
Подзапросы указывают после ключевого слова WITH. 
Порядок здесь другой, нежели в обычном запросе: сначала псевдоним, затем ключевое слово AS, а потом подзапрос в скобках.
Подзапросов после WITH может быть несколько: их перечисляют через запятую. 
Каждый подзапрос — это отдельная выборка данных, которую в дальнейшем можно использовать так же, как и таблицу из БД. После последнего подзапроса запятую не ставят — это означает начало основного запроса. 
    Псевдонимы подзапросов не должны повторяться между собой, иначе СУБД не поймёт, какой именно подзапрос нужно использовать.

WITH
-- назначение псевдонимов и формирование подзапросов
псевдоним_подзапроса_1 AS (подзапрос_1),
псевдоним_подзапроса_2 AS (подзапрос_2),
псевдоним_подзапроса_3 AS (подзапрос_3),
....
псевдоним_подзапроса_n AS (подзапрос_n)

SELECT -- основной запрос
-- внутри основного запроса работают с псевдонимами, которые назначили в WITH
FROM псевдоним_подзапроса_1 INNER JOIN псевдоним_подзапроса_2 ... 
...
... 

В основном запросе можно обращаться к общему табличному выражению по псевдониму. 
Необязательно обращаться к подзапросам в том порядке, в котором они заданы после WITH. 
Главное правило: подзапрос и, соответственно, его псевдоним должны быть заданы раньше, чем они начинают использоваться. 
Можно даже обращаться к подзапросу внутри другого подзапроса, если, конечно, первый подзапрос был задан раньше. 
Например, псевдоним_подзапроса_1 может быть использован в подзапросе_3. 
Теперь можно переписать запрос, который мы писали в прошлом теоретическом уроке, но с применением подзапросов и соединений. 
Напомним: нужно было получить таблицу с пятью странами, лидирующими по количеству заказов. 
Для каждой страны нужно было указать число зарегистрированных пользователей.  

WITH 
-- первый подзапрос с псевдонимом i от названия таблицы invoice
i AS (
    SELECT 
        billing_country AS country,
        COUNT(total) AS total_invoice
    FROM  chinook.invoice
    GROUP BY billing_country
    ORDER BY total_invoice DESC
    LIMIT 5
), -- подзапросы разделяют запятыми
-- второй подзапрос с псевдонимом c от названия таблицы clients
c AS (
    SELECT 
        country AS country,
        COUNT(customer_id) AS total_clients
    FROM chinook.client
    GROUP BY country
)
-- основной запрос, в котором указаны псевдонимы для подзапросов
SELECT 
    i.country,
    i.total_invoice,
    c.total_clients
FROM i LEFT JOIN c ON i.country=c.country
ORDER BY i.total_invoice DESC; 


Результат не изменился, зато код стал понятным и структурированным. 
Первый и второй подзапросы не зависят друг от друга, поэтому можно поменять их местами, результат выполнения запроса останется прежним.
Так как общее табличное выражение используется точно так же, как и любая таблица из БД, 
то нельзя обращаться напрямую к общим табличным выражениям после оператора WHERE. 
Обращение к любой таблице возможно только с использованием оператора FROM. 
Посмотрите на пример того, как можно добавить CTE  после WHERE, если фильтрация всё-таки необходима. 
В данном случае по странам с максимальной суммой заказов.

WITH 
i AS (
    SELECT 
        billing_country AS country,
        COUNT(total) AS total_invoice
    FROM  chinook.invoice
    GROUP BY billing_country
    ORDER BY total_invoice DESC
    LIMIT 5
)
    SELECT 
        country AS country,
        COUNT(customer_id) AS total_clients
    FROM chinook.client
    WHERE country in (SELECT country FROM i)
    GROUP BY country 

Это тоже использование подзапроса в основном коде, но более компактного по размеру. 
Без выражений с оператором WITH можно обойтись, но это удобный инструмент для реализации декомпозиции: одно общее табличное выражение — одна подзадача.