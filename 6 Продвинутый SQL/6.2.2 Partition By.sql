Оператор окна PARTITION BY
Продолжим работать с онлайн-магазином «Сила — в окнах». Описание данных — под катом.
Описание схем онлайн-магазина «Сила — в окнах»

В прошлом уроке с помощью запроса с пустым выражением OVER мы выгружали поле со средней выручкой по таблице и поле с суммарной выручкой — тоже по всей таблице.  
Усложним задачу, добавив разрез по дате. Рассчитаем среднюю выручку не по всей таблице, а для каждой даты отдельно. 
Попробуем решить задачу без оконной функции. Декомпозируем: сначала найдём среднее значение выручки для каждой даты, затем используем группировку и ограничим выгрузку тремя записями:

SELECT 
    event_dt, 
    AVG(revenue) AS date_avg
FROM online_store.orders
GROUP BY event_dt
LIMIT 3; 
event_dt	date_avg
2020-06-14	5.53439
2020-06-19	5.44484
2020-06-17	5.53998
Каждой дате соответствует среднее значение выручки.
Теперь добавим эти данные к основной таблице так, чтобы напротив каждой даты появилось соответствующее значение средней выручки. Например, напротив каждого значения 2020-06-14 должно появиться число 5.53439.
К исходным данным присоединим таблицу с расчётом средней выручки — по значению даты.

SELECT *
FROM online_store.orders AS ord
LEFT JOIN (
    SELECT 
        event_dt,
        AVG(revenue) AS date_avg
    FROM online_store.orders
    GROUP BY event_dt
) AS dt ON ord.event_dt = dt.event_dt; 
user_id	event_dt	revenue	event_dt	date_avg
55519067947	2020-06-14	5.62	2020-06-14	5.53439
831753022495	2020-06-14	1.33	2020-06-14	5.53439
284598472478	2020-06-14	4.93	2020-06-14	5.53439
725363192554	2020-06-14	1.55	2020-06-14	5.53439
324356134597	2020-06-14	9.6	2020-06-14	5.53439
…	…	…	…	…
Чтобы разделить данные на группы, используют параметр окна PARTITION BY.
Предыдущий код можно переписать:

SELECT 
    *,
    AVG(revenue) OVER (PARTITION BY event_dt) AS date_avg
FROM online_store.orders; 
Посмотрите, насколько лаконичнее и удобнее код с оконной функцией! Результат получим тот же, что и раньше: 
user_id	event_dt	revenue	date_avg
284598472478	2020-06-14	4.93	5.53439
725363192554	2020-06-14	1.55	5.53439
324356134597	2020-06-14	9.6	5.53439
962151445481	2020-06-14	3.44	5.53439
78269245488	2020-06-14	7.57	5.53439
…	…	…	…
К итоговой таблице добавится новое поле со средней выручкой. Только теперь она будет рассчитана не по всей таблице, как в случае с пустым выражением OVER, а для каждой даты отдельно.
Синтаксис
Разберём синтаксис запроса. Напомним, что окна, по которым будет рассчитана оконная функция, задают внутри выражения OVER.
Внутри OVER находится оператор PARTITION BY. Он разделяет записи на группы в зависимости от значения в поле event_dt, эти группы можно назвать окнами. Записи с одинаковым event_dt окажутся в одном окне. Этим оператор PARTITION BY похож на GROUP BY, который группирует записи, объединённые одним признаком или несколькими. 
Для каждого окна будет рассчитан результат оконной функции.
Описание иллюстрации — в тексте выше. 
Добавим среднюю выручку, которую принёс каждый пользователь. Для простоты возьмём не всех пользователей, а оставим в таблице несколько идентификаторов.

SELECT 
    *,
    AVG(revenue) OVER (PARTITION BY user_id) AS user_avg
FROM online_store.orders
WHERE user_id IN (300768196, 840452722, 59432616)
ORDER BY user_id; 
user_id	event_id	revenue	user_avg
59432616	2020-06-17	7.59	7.59
300768196	2020-06-25	8.74	7
300768196	2020-06-27	5.26	7
840452722	2020-06-19	5.81	5.08333
840452722	2020-06-21	3.17	5.08333
840452722	2020-06-24	6.27	5.08333
Записи с совпадающим user_id объединяются в одно окно, и среднее значение рассчитывается только внутри этого окна.
Схема работы оконной функции в последнем примере. Подробное описание иллюстрации — в тексте выше.
Разделы по нескольким полям
После PARTITION BY, как и после GROUP BY, можно указать несколько полей, и тогда окно сформируется по нескольким полям сразу. 
Если в запросе после PARTITION BY указать два поля: user_id и event_dt, — в одно окно войдёт каждая уникальная комбинация значений из этих полей. 
Как и в случае с GROUP BY, порядок, в котором указывают поля после PARTITION BY, не важен: он не влияет на формирование окна.

SELECT 
    *,
    AVG(revenue) OVER (PARTITION BY user_id, event_dt)
FROM online_store.orders 
WHERE user_id IN (300768196, 840452722, 59432616)
ORDER BY user_id; 
user_id	event_dt	revenue	avg
59432616	2020-06-17	7.59	7.59
300768196	2020-06-25	8.74	8.74
300768196	2020-06-27	5.26	5.26
840452722	2020-06-19	5.81	5.81
840452722	2020-06-21	3.17	3.17
840452722	2020-06-24	6.27	6.27
В примере значения для каждой комбинации полей, по которым формируют окна, уникальны. Поэтому оконная функция рассчитана для каждой записи отдельно. 
Рассмотрим ещё один пример, когда комбинации полей не уникальны.
За основу возьмём данные по длительности сессий пользователей, пришедших по разным каналам, из таблицы online_store.sessions. Для регионов Germany и France подсчитаем среднее время сессий (session_duration) для устройств iPhone и Android. Затем подсчитаем средние значения в разрезе региона и в разрезе региона и устройства с помощью оконных функций. 
Начнём с подготовки данных и рассчитаем средние значения для нужных регионов и устройств, используя CTE. Для упрощения результата будем округлять среднее время до двух значений после запятой.

WITH grouped_data AS (
    SELECT
        region,
        device,
        channel,
        ROUND(AVG(session_duration),2) AS avg_session_dur
    FROM online_store.sessions
    WHERE 
        region IN ('Germany','France') AND 
          device IN ('iPhone', 'Android')
    GROUP BY region, device, channel
)
SELECT *
FROM grouped_data 
region	device	channel	avg_session_dur
France	Android	AnotherSource	29.18
France	Android	Organic	29.87
France	Android	Yandex	30.21
France	iPhone	AnotherSource	28.98
France	iPhone	Organic	30.06
France	iPhone	Yandex	30.02
Germany	Android	AnotherSource	29.63
Germany	Android	Organic	30.38
Germany	Android	Yandex	29.70
Germany	iPhone	AnotherSource	30.58
Germany	iPhone	Organic	29.54
Germany	iPhone	Yandex	29.77
Теперь проведём необходимые расчёты и добавим две оконные функции, которые будут рассчитывать среднее значение длительности сессии в разрезе региона (avg_by_region) и среднее значение в разрезе региона и устройства (avg_by_region_device):

WITH grouped_data AS (
    SELECT
        region,
        device,
        channel,
        ROUND(AVG(session_duration),2) AS avg_session_dur
    FROM online_store.sessions
    WHERE 
        region IN ('Germany','France') AND 
          device IN ('iPhone', 'Android')
    GROUP BY region, device, channel
)
SELECT *,
    ROUND(AVG(avg_session_dur) OVER (PARTITION BY region),2) AS avg_by_region,
    ROUND(AVG(avg_session_dur) OVER (PARTITION BY region, device),2) AS avg_by_region_device
FROM grouped_data 
region	device	channel	avg_session_dur	avg_by_region	avg_by_region_device
France	Android	AnotherSource	29.18	29.72	29.75
France	Android	Organic	29.87	29.72	29.75
France	Android	Yandex	30.21	29.72	29.75
France	iPhone	AnotherSource	28.98	29.72	29.69
France	iPhone	Organic	30.06	29.72	29.69
France	iPhone	Yandex	30.02	29.72	29.69
Germany	Android	AnotherSource	29.63	29.93	29.90
Germany	Android	Organic	30.38	29.93	29.90
Germany	Android	Yandex	29.70	29.93	29.90
Germany	iPhone	AnotherSource	30.58	29.93	29.96
Germany	iPhone	Organic	29.54	29.93	29.96
Germany	iPhone	Yandex	29.77	29.93	29.96
Из таблицы выше хорошо видно, как в случае PARTITION BY region, группировка данных происходит в разрезе региона и полученное среднее значение по всему региону одинаковое. А при PARTITION BY region, device средние значения подсчитываются отдельно для каждого устройства в разрезе каждого региона и совпадают для пары значений region, device.
Напомним, что для расчёта значений по разделам можно использовать и другие функции: MIN, MAX, COUNT и SUM.
При использовании оператора PARTITION BY можно также определять порядок, в котором строки будут обрабатываться оконными функциями, используя ORDER BY в OVER. В таком случае агрегация будет происходить с накоплением. Через несколько уроков подробно поговорим о расчёте накопительных или кумулятивных значений.
Пока предлагаем закрепить то, что вы узнали oб операторе PARTITION BY.
Выберите верные утверждения:


Для правильной работы оконной функции нужно всегда использовать PARTITION BY
PARTITION BY — необязательный оператор оконной функции.

Правильный ответ
С помощью PARTITION BY можно определить группы, или разделы, по которым будут рассчитаны оконные функции
Оператор PARTITION BY похож на GROUP BY, который группирует записи, объединённые одним признаком или несколькими, только объединение происходит в рамках оконной функции.

Правильный ответ
С PARTITION BY можно использовать все агрегатные функции, такие как MIN, MAX, SUM, AVG, COUNT
Эти агрегатные функции можно использовать совместно с PARTITION BY.

PARTITION BY всегда используется совместно с оператором HAVING
PARTITION BY всегда используется в выражении OVER, а HAVING используется только после GROUP BY.

Правильный ответ
С PARTITION BY можно использовать поля с различными типами данных: числами, датами, символами и др.
Тип данных поля в PARTITION BY не будет влиять на результат.

Правильный ответ
PARTITION BY можно использовать в сочетании с ORDER BY в выражении OVER
Такое возможно. Например, совместное использование с ORDER BY позволяет агрегировать данные по группам с накоплением.

PARTITION BY можно использовать без указания полей
PARTITION BY используется только с указанием полей, по которым будет рассчитана оконная функция.

Порядок строк в PARTITION BY устанавливается автоматически по возрастанию значений
Порядок строк в каждой группе можно определить, используя оператор ORDER BY.
Теперь давайте применять оконные функции на практике.