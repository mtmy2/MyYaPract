Функции для работы с JSON и JSONB
Вы уже знакомы с операторами для json и jsonb, а в этом уроке изучите несколько наиболее часто используемых функций, которые пригодятся вам при работе с этими форматами. 

JSON_ARRAY_LENGTH и JSONB_ARRAY_LENGTH
Иногда нужно узнать количество элементов массива json. 
Например, информация о детях сотрудника хранится в массиве, и нужно узнать, сколько у сотрудника детей. Для этого пригодятся функции, которые возвращают длину массива json или jsonb:

SELECT jsonb_array_length(
    '[
        {"name": "Артем", "age": "5"}, 
        {"name": "Инна", "age": "2"}
    ]'::jsonb
) 
В этом массиве два json-объекта, поэтому результат — 2.
JSON_EACH и JSONB_EACH
Эти функции разворачивают json/jsonb в набор пар ключ-значение. В результате получается две колонки: в первой — ключ текстового формата, во второй — значение в формате json/jsonb. Строк в результате будет столько, сколько пар ключ-значение содержится в исходном json-объекте. 
В конструкции SELECT эту функцию ставят после слова FROM:

SELECT * FROM jsonb_each(
    '{
        "name": "Колесов Игорь Витальевич",
        "birth_date": "12.06.1985",
        "children": [
            {
                "relationship": "сын",
                "name": "Колесов Артем"
            },
            {
                "relationship": "дочь",
                "name": "Колесова Инна"
            }
        ]
    }'::jsonb) 
А вот результат:
key text	value jsonb
1	name	"Колесов Игорь Витальевич”
	children	[{"name":"Колесов Артем","relationship":"сын"},{"name":"Колесова Инна","relationship":"дочь"}]
	birth_date	"12.06.1985"

Посмотрите на пример, как применить функцию jsonb_each  к полю таблицы, в которой несколько записей. В CTE j_object имитируем создание такой таблицы:

    WITH j_object AS (
    SELECT 1 AS id,
        '{
        "name": "Колесов Игорь Витальевич",
        "birth_date": "12.06.1985",
        "children": [
            {
                "relationship": "сын",
                "name": "Колесов Артем"
            },
            {
                "relationship": "дочь",
                "name": "Колесова Инна"
            }
        ]
    }'::jsonb AS example
    UNION ALL
    SELECT 2 AS id,
        '{
        "name": "Петров Сергей Алексеевич",
        "birth_date": "05.11.1989",
        "children": [
            {
                "relationship": "сын",
                "name": "Петров Алексей"
            }
        ]
    }'::jsonb
    UNION ALL
    SELECT 3 AS id,
        '{
        "name": "Луговая Ирина Анатольевна",
        "birth_date": "18.04.1977"
    }'::jsonb
    )
    SELECT id,
           (jsonb_each(example)).key,
           (jsonb_each(example)).value
    FROM j_object; 

В этом случае JSON-объект из каждой записи развернётся отдельно:
id	key	value
1	name	Колесов Игорь Витальевич
1	children	[{"name": "Колесов Артем", "relationship": "сын"}, {"name": "Колесова Инна", "relationship": "дочь"}]
1	birth_date	12.06.1985
2	name	Петров Сергей Алексеевич
2	children	[{"name": "Петров Алексей", "relationship": "сын"}]
2	birth_date	05.11.1989
3	name	Луговая Ирина Анатольевна
3	birth_date	18.04.1977
Также есть очень похожие функции JSON_EACH_TEXT и JSONB_EACH_TEXT. Они возвращают все значения в формате text.
JSON_ARRAY_ELEMENTS и JSONB_ARRAY_ELEMENTS
Эти функции разворачивают массив в набор значений. В результате получается колонка с типом json/jsonb и таким количеством строк, сколько значений содержит массив:

SELECT jsonb_array_elements(
    '[{"name": "Артем", "age": "5"}, {"name": "Инна", "age": "2"}]'::jsonb
); 

Результат запроса будет таким:
jsonb_array_elements jsonb
1	{"age": "5", "name": "Артем"}
2	{"age": "2", "name": "Инна"}


JSONB_SET
Эта функция работает только с форматом jsonb. Она позволяет заменить в объекте jsonb любое значение ключа на новое. 
В функцию передают такие параметры:
jsonb-объект, в котором нужно поменять значение.
Путь, по которому будут менять значения, в виде текстового массива.
Новое значение в формате jsonb.
Булево значение true или false — добавлять ли элемент, если по заданному пути ничего не найдётся. 
Этот атрибут можно не указывать, по умолчанию он равен true.
Допустим, нужно заменить имя сына водителя Колесова «Артем» на «Артём». 
Путь к этому элементу такой: объект children — в нём элемент массива с индексом 0 — в нём объект name. 
В формате текстового массива это выглядит так: '{children, 0, name}'. 
Осталось указать новое значение, заключив его в двойные кавычки, чтобы синтаксис был корректен для формата jsonb. Последний аргумент указывать не нужно:

SELECT jsonb_set(jsonb_build_object(
    'name', 'Колесов Игорь Витальевич', 
    'birth_date', '12.06.1985', 
    'children', jsonb_build_array(
        jsonb_build_object('relationship', 'сын', 'name', 'Колесов Артем'), 
        jsonb_build_object('relationship', 'дочь', 'name', 'Колесова Инна'))
     ), '{children, 0, name}', '"Колесов Артём"'
); 
Значение успешно изменилось:
Имя Артём записано с буквой ё
Эту функцию также можно использовать, если вы хотите изменить значение jsonb в таблице. Например, можно добавить ещё одну строку в таблицу questionnaires из прошлого урока:

INSERT INTO taxi.questionnaires(id, form)
VALUES (
    2,
    jsonb_build_object(
        'name', 'Колесов Игорь Витальевич', 
        'birth_date', '12.06.1985', 
        'children', jsonb_build_array(
            jsonb_build_object('relationship', 'сын', 'name', 'Колесов Артем'), 
            jsonb_build_object('relationship', 'дочь', 'name', 'Колесова Инна'))
     )
) 
А затем исправить «Артем» на «Артём» с помощью UPDATE:

UPDATE taxi.questionnaires
SET form = jsonb_set(form, '{children, 0, name}', '"Колесов Артём"')
WHERE id = 2 
Вы разобрали несколько основных функций, полный список функций для работы с json/jsonb можно посмотреть в документации PostgreSQL.
У последнего элемента json-массива my_json_arr индекс 5. Какой результат выдаст такой запрос? Выберите единственный верный ответ.

SELECT json_array_length(my_json_arr) 


4

5

Правильный ответ
6
Ваши подсчёты верны: такая длинна скрывается под индексами от 0 до 5.

1
Сколько строк и столбцов получится в результате такого запроса? Выберите единственный верный ответ.

SELECT * FROM json_each(
    '{
        "title": "Война и мир",
        "author": "Толстой Л.Н.",
        "published": 1985,
        "characters": [
             {
                 "name": "Наташа Ростова",
                 "dignity": "графиня"
             },
             {
                 "name": "Пьер Безухов",
                 "dignity": "граф"
             },
             {
                 "name": "Андрей Болконский",
                 "dignity": "князь"
             }
        ]
    }'::json) 


1 столбец, 4 строки

1 столбец, 10 строк

Правильный ответ
2 столбца, 4 строки
Функция даёт два столбца, key и value, каждому ключу верхнего уровня соответствует отдельная строка. В этом массиве ключей верхнего уровня 4.

2 столбца, 10 строк

2 столбца, 6 строк
Какой результат будет у такого запроса? Выберите все верные ответы.

SELECT jsonb_set('{
           "title": "Война и мир",
           "author": "Толстой Л.Н.",
           "published": 1985,
           "characters": [
              {
                  "name": "Наташа Ростова",
                  "dignity": "графиня"
              },
              {
                  "name": "Пьер Безухов",
                  "dignity": "граф"
              },
              {
                 "name": "Андрей Болконский",
                 "dignity": "князь"
              }
          ]
    }'::jsonb, '{characters, 1, dignity}', '"?"') 



{
    "title": "Война и мир",
    "author": "Толстой Л.Н.",
    "published": 1985,
    "characters": [
        {
            "name": "Наташа Ростова",
            "dignity": "графиня?"
        },
        {
            "name": "Пьер Безухов",
            "dignity": "граф"
        },
        {
            "name": "Андрей Болконский",
            "dignity": "князь"
        }
    ]
} 


{
    "title": "Война и мир",
    "author": "Толстой Л.Н.",
    "published": 1985,
    "characters": [
        {
            "name": "Наташа Ростова",
            "dignity": "графиня"
        },
        {
            "name": "Пьер Безухов",
            "dignity": "граф?"
        },
        {
            "name": "Андрей Болконский",
            "dignity": "князь"
        }
    ]
} 


{
    "title": "Война и мир",
    "author": "Толстой Л.Н.",
    "published": 1985,
    "characters": [
        {
            "name": "Наташа Ростова",
            "dignity": "?"
        },
        {
            "name": "Пьер Безухов",
            "dignity": "граф"
        },
        {
            "name": "Андрей Болконский",
            "dignity": "князь"
        }
    ]
} 

Правильный ответ

{
    "title": "Война и мир",
    "author": "Толстой Л.Н.",
    "published": 1985,
    "characters": [
        {
            "name": "Наташа Ростова",
            "dignity": "графиня"
        },
        {
            "name": "Пьер Безухов",
            "dignity": "?"
        },
        {
            "name": "Андрей Болконский",
            "dignity": "князь"
        }
    ]
} 

Функция jsonb_set заменяет значение ключа в JSON-объекте на “?”. Путь в фигурных скобках указывает на ключ dignity в первом элементе массива characters.