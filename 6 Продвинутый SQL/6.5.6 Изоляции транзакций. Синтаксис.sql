Изоляции транзакций. Синтаксис
В прошлом уроке вы узнали, какие есть уровни изоляции, и рассмотрели особенности их реализации в PostgreSQL. В этом уроке вы продолжите изучать транзакции: познакомитесь с синтаксисом запросов с транзакциями разных уровней изоляции в PostgreSQL и разберёте работу уровней изоляции на примерах.
Установить нужный уровень изоляции для транзакции можно несколькими способами.
Указать при старте:

BEGIN TRANSACTION ISOLATION LEVEL <*нужный_уровень_изоляции*>; 
Задать командой SET TRANSACTION ISOLATION LEVEL внутри транзакции. Команда выполняется после старта, но до выполнения любых операций в рамках этой транзакции:

BEGIN;
   SET TRANSACTION ISOLATION LEVEL <*нужный_уровень_изоляции*>; 
Задать командой SET SESSION CHARACTERISTICS AS TRANSACTION ISOLATION LEVEL для всей сессии. Команда устанавливает уровень изоляции для всех будущих транзакций в текущей сессии:

SET SESSION CHARACTERISTICS AS TRANSACTION ISOLATION LEVEL 
<*нужный_уровень_изоляции*>; 
Чтобы в процессе работы изменить уровень изоляции транзакции или сессии, выполните команду SET TRANSACTION .. или SET SESSION .. ещё раз.
Если при открытии транзакции нигде явно не указать, какой уровень изоляции использовать, PostgreSQL считает, что достаточно уровня READ COMMITTED и по умолчанию использует его.
Выполняйте запросы из примеров по ходу урока в своем менеджере БД. Примеры в уроке выполнены в DBeaver, но вы по желанию можете использовать другой клиент. 
Пример 1 — как работает уровень изоляции READ COMMITTED
Создайте тестовую таблицу products:

DROP TABLE IF EXISTS products CASCADE;

CREATE TABLE products (
    name VARCHAR,
    price NUMERIC(10, 2)
);

INSERT INTO products (name, price)
VALUES
    ('Product 1', 12.50),
    ('Product 2', 10.40),
    ('Product 3', 7.99),
    ('Product 4', 14.99); 
Откройте транзакцию уровня изоляции READ COMMITTED. Указывать уровень явно нет необходимости, так как READ COMMITTED используется по умолчанию. В транзакции проверьте максимальное значение цены среди всех продуктов:

BEGIN;
SHOW transaction_isolation;
SELECT MAX(price) FROM products; 
Команда SHOW transaction_isolation; вернёт значение:
transaction_isolation text
1	read committed
Теперь откройте новое окно запроса, запустите в этом окне новую транзакцию и выведите максимальное значение цены из таблицы products. Убедитесь, что результаты запросов с MAX совпадают:
Иллюстрация текста выше — результаты запросов совпадают
Далее в окне  для транзакции 1 выполните INSERT и снова проверьте максимальное значение:

INSERT INTO products (name, price)
VALUES ('Product 5', 50.40);
SELECT MAX(price) FROM products; 
Во втором окне выполните только SELECT и убедитесь, что максимальное значение не изменилось:
Иллюстрация текста выше — значение не изменилось
Почему максимальное значение цены во второй транзакции не изменилось? Отметьте все возможные причины:


Указан уровень изоляции READ UNCOMMITTED.
В этом запросе другой уровень изоляции.

Правильный ответ
Указан уровень изоляции READ COMMITTED.
READ COMMITTED позволяет увидеть только зафиксированные изменения.

Указан уровень изоляции REPEATABLE READ.
В этом запросе другой уровень изоляции.

Правильный ответ
Не выполнен COMMIT в первой транзакции.
Увидеть неподтверждённые изменения другой транзакции не получится. Чтобы данные, внесённые командой INSERT в первой транзакции, стали доступны во второй транзакции, нужно завершить первую транзакцию командой COMMIT. До тех пор, пока не будет выполнен COMMIT в транзакции, которая вносит изменения в данные, другие транзакции не смогут увидеть эти изменения.
Выполните команду COMMIT в первом окне и ещё раз проверьте результат во втором:
Иллюстрация текста выше
Максимальное значение цены в окне транзакции 2 также изменилось. Когда вы только начали вторую транзакцию, максимальное значение цены было одно. Через некоторое время в этой же транзакции вы получили другое максимальное значение цены. Это пример аномалии «фантомное чтение», которая может появляться в транзакциях уровня READ COMMITTED.
Выполните команду COMMIT, чтобы закрыть транзакцию 2.
Пример 2 — как работает уровень изоляции REPEATABLE READ
Проверьте, действительно ли уровень изоляции REPEATABLE READ в PostgreSQL поможет избежать аномалии фантомного чтения, которую вы получили в предыдущем примере. 
Выполните те же действия, что и в первом примере, только для транзакции 1 укажите  уровень изоляции REPEATABLE READ.
Закройте все открытые транзакции прошлого примера, если такие остались. 
В первом окне начните новую транзакцию и выполните запрос для получения максимального значения цены:

BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
    SELECT MAX(price) FROM products; 
Во втором окне откройте новую транзакцию, её уровень изоляции неважен.
Измените значение цены для 'Product 5' и зафиксируйте изменения командой COMMIT;:

BEGIN;
    UPDATE products
    SET price = 100.00
    WHERE name = 'Product 5';
COMMIT; 
Так как здесь всего один UPDATE-запрос в рамках транзакции, необязательно объявлять его отдельной транзакцией. 
В PostgreSQL если запрос не вложен в явно объявленную транзакцию с использованием команд BEGIN, COMMIT или ROLLBACK, он считается автономной транзакцией. Это значит, что каждый запрос выполняется в своей транзакции и автоматически подтверждается при успешном завершении (COMMIT) или откатывается в случае ошибки (ROLLBACK).
Это называется автокоммит (англ. autocommit) — он гарантирует атомарность каждого отдельного запроса.
Вернитесь к первой транзакции и снова выполните запрос SELECT. Максимальное значение не изменилось:
Иллюстрация текста выше — значение не изменилось
Это произошло потому, что изменения, зафиксированные в других транзакциях, не должны быть видны в рамках текущей транзакции до её завершения. 
Если сейчас для первой транзакции выполнить COMMIT; и проверить максимальное значение, оно уже будет другим — соответствующим изменённой цене:
Иллюстрация текста выше.
Итак, вы убедились — уровень изоляции REPEATABLE READ в PostgreSQL гарантирует стабильность данных во время транзакции, предотвращая их изменение из других транзакций.
Такой уровень изоляции может быть полезен в ситуациях, когда нужно сделать много сложных вычислений. Например, для аналитической отчётности — если вычисления могут занять длительное время и важно, чтобы в течение этого времени уже полученные промежуточные результаты не менялись, даже если эти данные были изменены другими транзакциями. Потому что фантомные чтения могут привести к несогласованным результатам внутри итогового отчёта.
Пример 3 — аномалия сериализации, какая ты?
Для работы с товарами на разных складах ведут журнал учёта, в котором отмечают:
полную историю поступлений товара на склад,
дату получения товара,
актуально ли количество товара (булево значение).
Создайте таблицу для хранения данных журнала:

CREATE TABLE warehouse_movements
(
    id SERIAL PRIMARY KEY,
    store_id INTEGER,
    product_id CHARACTER(5),
    quantity INTEGER,
    update_date TIMESTAMP WITHOUT TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    is_actual BOOL DEFAULT TRUE
); 
Добавьте строки для тестирования:

INSERT INTO warehouse_movements (
    store_id,
    product_id,
    quantity)
VALUES
    (1, 'A', 100),
    (1, 'B', 100),
    (2, 'A', 200),
    (2, 'B', 200); 
'A' и 'B'  — это товар на складах 1 и 2. 
Оказалось, что товары 'A' и 'B' ошибочно промаркировали как разные. Поэтому решили эти товары со склада 1 переместить на склад 2, просуммировать их количество и обозначить такой товар как 'C', а на складе отметить товары неактуальными. 
В это же время менеджер склада 2 решил отправить все свои товары: 'A', 'B' и 'C' на склад 1, также просуммировав и обозначив как товар с новым кодом, — вот такой непостоянный менеджмент склада.
Итого: сумма всех товаров со склада 1 добавляется как новая строка, но на склад 2, а сумма всех товаров со склада 2  — как новая строка на склад 1:
Таблица cо складами, товарами и их количеством — иллюстрация текста выше
Откройте два новых окна и в каждом начните транзакции уровня изоляции REPEATABLE READ:

BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ; 
В первом окне для транзакции 1 выполните код:

-- Переместите товары со склада 1 на склад 2 и промаркируйте как товар 'C':
INSERT INTO warehouse_movements (
    store_id,
    product_id,
    quantity)
SELECT 2, 'C', qnt
FROM (
    SELECT SUM(quantity) AS qnt
    FROM warehouse_movements
    WHERE store_id = 1) AS t; 
Во втором окне для транзакции 2 выполните код:

-- Переместите все товары со склада 2 на склад 1 и промаркируйте как товар 'C':
INSERT INTO warehouse_movements (
    store_id,
    product_id,
    quantity)
SELECT 1, 'C', qnt
FROM (
    SELECT sum(quantity) AS qnt
    FROM warehouse_movements
    WHERE store_id = 2) AS t;
 
Выполните запросы, чтобы показать неактуальность товаров, и завершите транзакции. Сначала первую:

-- Укажите, что записи для склада 1 стали неактуальны:
UPDATE warehouse_movements
SET is_actual = FALSE
WHERE store_id = 1;

COMMIT; 
Потом вторую:

-- Укажите, что записи для склада 2 стали неактуальны:
UPDATE warehouse_movements
SET is_actual = FALSE
WHERE store_id = 2;

COMMIT; 
Проверьте результат работы в таблице warehouse_movements:
id	store_id	product_id	quantity	update_date	is_actual
1	1	A	100	2024-07-28 11:47:15.827407	FALSE
2	1	B	100	2024-07-28 11:47:15.827407	FALSE
3	2	A	200	2024-07-28 11:47:15.827407	FALSE
4	2	B	200	2024-07-28 11:47:15.827407	FALSE
5	2	C	200	2024-07-28 11:48:22.545667	TRUE
6	1	C	400	2024-07-28 11:48:34.287354	TRUE
Если бы транзакции выполнялись последовательно: сначала первая, затем вторая, то во второй транзакции использовались бы данные, полученные после работы первой, которая уже отправила свои товары под маркировкой ‘C’ на второй склад. В итоге все товары переехали бы на первый склад и результат был бы такой:
id	store_id	product_id	quantity	update_date	is_actual
1	1	A	100	2024-07-28 11:47:15.827407	FALSE
2	1	B	100	2024-07-28 11:47:15.827407	FALSE
3	2	A	200	2024-07-28 11:47:15.827407	FALSE
4	2	B	200	2024-07-28 11:47:15.827407	FALSE
5	2	C	200	2024-07-28 11:48:22.545667	FALSE
6	1	C	600	2024-07-28 11:49:48.765238	TRUE
Если сначала выполнилась бы вторая транзакция, а после неё первая, на данных, полученных от второй, то все товары оказались бы на втором складе: 
id	store_id	product_id	quantity	update_date	is_actual
1	1	A	100	2024-07-28 11:47:15.827407	FALSE
2	1	B	100	2024-07-28 11:47:15.827407	FALSE
3	2	A	200	2024-07-28 11:47:15.827407	FALSE
4	2	B	200	2024-07-28 11:47:15.827407	FALSE
5	1	C	400	2024-07-28 11:48:22.545667	FALSE
6	2	C	600	2024-07-28 11:48:52.996538	TRUE
Результат параллельного выполнения транзакций отличается от результата при их последовательном выполнении, который чаще всего бывает ожидаемым, — это и есть аномалия сериализации. Однако при уровне изоляции REPEATABLE READ эта аномалия не приводит к ошибке и не вызывает откат транзакции. Тогда пользователь не сможет узнать о некорректном результате: все его товары параллельной транзакцией отправили на другой склад.
Пересоздайте таблицу warehouse_movements и ещё раз выполните код из примера 3 с одной разницей — теперь установите уровень изоляции SERIALIZABLE. Какой будет результат? Выберите один верный ответ.


На складе 1 актуальное количество товара 'C' = 600.
Проверьте, что всё сделали верно. На уровне изоляции SERIALIZABLE аномалия сериализации заканчивается ошибкой: «не удалось сериализовать доступ из-за зависимостей чтения/записи между транзакциями».

На складе 2 актуальное количество товара 'C' = 600.
Проверьте, что всё сделали верно. На уровне изоляции SERIALIZABLE аномалия сериализации заканчивается ошибкой: «не удалось сериализовать доступ из-за зависимостей чтения/записи между транзакциями».

Тоже правильный ответ
Одна из транзакций завершилась ошибкой:
ERROR:  could not serialize access due to read/write dependencies among transactions
SQL state: 40001
Detail: Reason code: Canceled on identification as a pivot, during commit attempt.
Hint: The transaction might succeed if retried.

ОШИБКА: не удалось сериализовать доступ из-за зависимостей чтения/записи между
        транзакциями
 
На уровне изоляции SERIALIZABLE аномалия сериализации заканчивается ошибкой: «не удалось сериализовать доступ из-за зависимостей чтения/записи между транзакциями».

Неправильный ответ
Одна из транзакций завершилась ошибкой:
ERROR:  could not serialize access due to concurrent update
SQL state: 40001

ОШИБКА: не удалось сериализовать доступ из-за параллельного обновления
 
На уровне изоляции SERIALIZABLE аномалия сериализации заканчивается ошибкой: «не удалось сериализовать доступ из-за зависимостей чтения/записи между транзакциями».
Вы изучили синтаксис запросов с транзакциями в PostgreSQL и разобрали, как работают разные уровни изоляции. В следующем уроке вас ждёт практика по теме изоляций транзакций.

