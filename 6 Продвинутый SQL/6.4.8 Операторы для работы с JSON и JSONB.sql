Операторы для работы с JSON и JSONB
В прошлом уроке вы познакомились с типами данных json и jsonb и разобрали их особенности. В этом уроке вы узнаете, какие операторы есть в PostgreSQL специально для этих типов данных.
В этот раз вы будете работать не с таблицами, а формировать json/jsonb с помощью оператора SELECT. Например, вот так:

SELECT <значение типа json/jsonb><операторы/функции> 
Вы также можете использовать все рассмотренные операторы и функции в запросах INSERT/UPDATE, когда вам понадобится добавить или изменить значение json/jsonb внутри таблицы.



Операторы json



Для чтения. Чтобы прочитать значение какого-то определённого ключа из ячейки с форматом json/jsonb, применяют операторы -> и ->>. 
Разница между ними такая: 
оператор ->> всегда возвращает результат типа text,
оператор -> возвращает результат типа json или jsonb.
Например, чтобы извлечь имя родителя по ключу ‘name’ из анкеты произвольного формата, используют такие запросы:

SELECT 
    '{
        "name": "Колесов Игорь Витальевич",
        "children": [
            {
                "relationship": "сын",
                "name": "Колесов Артем"
            },
            {
                "relationship": "дочь",
                "name": "Колесова Инна"
             }
        ],
        "birth_date": "12.06.1985"
    }'::jsonb -> 'name';

SELECT 
    '{
        "name": "Колесов Игорь Витальевич",
        "children": [
            {
                "relationship": "сын",
                "name": "Колесов Артем"
            },
            {
                "relationship": "дочь",
                "name": "Колесова Инна"
            }
        ],
        "birth_date": "12.06.1985"
    }'::jsonb ->> 'name'
 
Результат первого запроса типа jsonb заключён в кавычки:
"Колесов Игорь Витальевич"
Результат второго — обычный text:
Колесов Игорь Витальевич


Для поиска. С помощью этих операторов также можно искать элементы массива по индексу элемента. Обратите внимание, что индексация в json-массивах начинается с 0.
Например, найдите первого ребёнка водителя Колесова. Для этого сначала нужно получить массив children в формате jsonb с помощью оператора ->, а затем получить элемент массива с индексом 0:

SELECT 
    '{
        "name": "Колесов Игорь Витальевич",
        "children": [
            {
                "relationship": "сын",
                "name": "Колесов Артем"
            },
            {
                "relationship": "дочь",
                "name": "Колесова Инна"
            }
        ],
        "birth_date": "12.06.1985"
    }'::jsonb -> 'children' -> 0
 
Результат — также в формате jsonb:
{"name": "Колесов Артем", "relationship": "сын"}
Можно обращаться к элементу массива с помощью отрицательного индекса. -1 означает первый элемент с конца, -2 — второй и так далее. С отрицательным индексом поиск того же самого объекта выглядит так:

SELECT 
    '{
        "name": "Колесов Игорь Витальевич",
        "children": [
            {
                "relationship": "сын",
                "name": "Колесов Артем"
            },
            {
                "relationship": "дочь",
                "name": "Колесова Инна"
            }
        ],
        "birth_date": "12.06.1985"
    }'::jsonb -> 'children' -> -2
 
Создавая цепочку из операторов чтения json, можно получать элементы из различных сложных вложенных структур.
Также для поиска по вложенным объектам можно использовать операторы #> и #>>. Они выдают значение по пути. Путь — это последовательный перечень всех вложенных друг в друга ключей, которые ведут к искомому значению. Его записывают в фигурных скобках через запятую и без кавычек. #> — возвращает формат jsonb, #>> — формат text.
Рассмотрим пример с вложенными json-объектами:

SELECT 
    '{
        "name": "Иван",
        "education": {
            "year": 1995,
            "school": "экономика и право"
        }
    }'::jsonb #>> '{education, year}'
 
Результат — 1995, также в формате text:
1995



Операторы #> и #>> также можно использовать, если есть вложенный массив элементов. В этом случае в строку пути включают индекс элемента в массиве:

SELECT 
    '{
        "name": "Иван",
        "education": {
            "year": 1995,
            "school": "экономика и право"
        },
        "children": ["Таня", "Ваня"]
    }'::jsonb #>> '{children, 0}'
 
Результат:
Таня
Такой поиск можно осуществлять и в том случае, если вам нужно использовать значение jsonb, хранящееся в таблице. Например, есть таблица с анкетами сотрудников:

CREATE TABLE taxi.questionnaires (
    id bigint,
    form jsonb
) 
В ней есть данные, которые добавили таким запросом:

INSERT INTO taxi.questionnaires(id, form)
VALUES (
    1,
    '{
         "name": "Иван",
         "education": {
             "year": 1995,
             "school": "экономика и право"
         },
         "children": ["Таня", "Ваня"]
    }'
) 
Тогда имя первого ребенка в анкете с id = 1 можно найти так:

SELECT form #>> '{children, 0}'
FROM taxi.questionnaires
WHERE id = 1 

Урок получился насыщенным. Сейчас вы на середине: операторы json покорены, впереди — операторы jsonb. Если вы устали и чувствуете, что нужен перерыв, — прислушайтесь к себе. Отдохните и продолжайте с новыми силами. Будет интересно!
Операторы jsonb
В дополнение к рассмотренным выше операторам, для jsonb в PostgreSQL есть отдельные операторы, которых нет для json. Некоторые из них напоминают операторы для массивов, которые вы разбирали в одном из предыдущих уроков.
Конкатенация (слияние)
Оператор конкатенации позволяет соединить два объекта jsonb:

SELECT 
    '{
        "name": "Иван",
        "education": {
            "year": 1995,
            "school": "экономика и право"
        }
     }'::jsonb || '{"age": "40"}'::jsonb 
Обратите внимание на результат:
Возраст: 40, имя: Иван, образование: год — 1995, школа — Экономика и право
В отличие от массива, порядок расположения объектов в запросе не гарантирует их расположение в таком же порядке в результате — ведь это jsonb, и в нём порядок элементов не важен. 
Вхождение
Ещё один знакомый вам по теме массивов оператор @> — или <@ — проверяет вхождение одного объекта в другой. Символ «собаки» (@) обращён к тому объекту, который больше, в котором ищут вхождение:

SELECT 
    '{
        "name": "Иван",
        "education": {
            "year": 1995,
            "school": "экономика и право"
        }
    }'::jsonb @> '{"name": "Иван"}'::jsonb 
Такой скрипт даёт результат true. 
При этом проверяются только элементы верхнего уровня, без вложенных, то есть такой скрипт вернёт false:

SELECT 
    '{
        "name": "Иван",
        "education": {
            "year": 1995,
            "school": "экономика и право"
        }
    }'::jsonb @> '{"school": "экономика и право"}'::jsonb 
Однако можно сначала получить объект education и в нём уже проверить вхождение. В этом случае запрос вернёт true.

SELECT 
    '{
        "name": "Иван",
        "education": {
            "year": 1995,
            "school": "экономика и право"
        }
    }'::jsonb -> 'education' @> '{"school": "экономика и право"}'::jsonb 
Присутствие
Наличие (присутствие) ключа верхнего уровня в объекте проверяет отдельная группа операторов. При этом вложенные объекты не рассматриваются, поскольку они не являются верхним уровнем.
Проверяют присутствие так:

SELECT 
    '{
        "name": "Иван",
        "education": {
            "year": 1995,
            "school": "экономика и право"
        }
    }'::jsonb ? 'education' 
Этот запрос даст результат true, поскольку education — один из ключей объекта.
Также можно проверять присутствие целого массива ключей. Если нужно узнать, присутствует ли хотя бы один элемент из массива, используйте оператор ?|:

SELECT 
    '{
        "name": "Иван",
        "education": {
            "year": 1995,
            "school": "экономика и право"
        }
    }'::jsonb ?| array['education', 'age'] 
Этот запрос выдал true, хотя ключа age нет. 
Если же нужно узнать, встречаются ли все элементы массива в качестве ключей, используйте оператор ?&:

SELECT 
    '{
        "name": "Иван",
        "education": {
            "year": 1995,
            "school": "экономика и право"
        }
    }'::jsonb ?& array['education', 'age'] 
Результат этого запроса — false.





Удаление



С помощью оператора «минус» - можно удалить ключ из объекта или объект из массива. 
Например, удалите возраст сотрудника. Для этого по левую сторону от минуса укажите jsonb-объект, а по правую — текстовое значение age. Это ключ, который нужно удалить:

SELECT 
    '{
        "name": "Иван",
        "age": 40,
        "education": {
            "year": 1995,
            "school": "экономика и право"
        }
    }'::jsonb - 'age' 
Сравните результат:
Имя: Иван, образование: год — 1995, школа — Экономика и право
Если по левую сторону от минуса поставить jsonb-массив, а по правую — число в формате integer, то элемент с таким индексом удалится из массива:

SELECT 
    '[
        {"name": "Алла", "age": "10"},
        {"name": "Артем", "age": "5"}, 
        {"name": "Инна", "age": "2"}
    ]'::jsonb - 1 
Вот так, элемент с индексом 1 удалён:
[{"age": "10", "name": "Алла"}, {"age": "2", "name": "Инна"}]
Если в массиве нет элемента с удаляемым индексом, массив не поменяется.
С операторами разобрались, впереди — квизы. Их будет целых пять, поэтому если вы ещё не отдыхали, стоит передохнуть и подкрепиться. Бон апети и успехов!
Какой результат выдаст такой запрос? Отметьте единственный верный вариант ответа.

SELECT 
    '{
        "title": "Война и мир",
        "author": "Толстой Л.Н.",
        "published": 1985,
        "characters": [
            {
                "name": "Наташа Ростова",
                "dignity": "графиня"
            },
            {
                "name": "Пьер Безухов",
                "dignity": "граф"
            },
            {
               "name": "Андрей Болконский",
               "dignity": "князь"
            }
        ]
    }'::jsonb -> 'characters' -> 1 -> 'name' 


«Наташа Ростова» в формате text.
Индексация jsonb-массива начинается с 0, поэтому первый элемент из characters — не Наташа Ростова.

«Наташа Ростова» в формате jsonb.
Индексация jsonb-массива начинается с 0, поэтому первый элемент из characters — не Наташа Ростова.

«Пьер Безухов» в формате text.
Оператор -> даёт результат в формате jsonb.

Правильный ответ
«Пьер Безухов» в формате jsonb.
Индексация jsonb-массива начинается с 0, значит, элемент с индексом 1 — это Пьер Безухов. Кроме того, оператор -> выдаёт результат в формате jsonb.
Какой результат может быть у такого запроса? Выберите все возможные варианты.

SELECT 
   '{
        "title": "Война и мир",
        "author": "Толстой Л.Н.",
        "published": 1985,
        "characters": [
            {
                "name": "Наташа Ростова",
                "dignity": "графиня"
            },
            {
                "name": "Пьер Безухов",
                "dignity": "граф"
            },
            {
               "name": "Андрей Болконский",
               "dignity": "князь"
            }
        ]
    }'::jsonb || '{"genre": "роман-эпопея"}'::jsonb 


Правильный ответ

{
    "title": "Война и мир",
    "author": "Толстой Л.Н.",
    "published": 1985,
    "characters": [
        {
            "name": "Наташа Ростова",
            "dignity": "графиня"
        },
        {
            "name": "Пьер Безухов",
            "dignity": "граф"
        },
        {
            "name": "Андрей Болконский",
            "dignity": "князь"
        }
    ],
    "genre": "роман-эпопея"
} 
Поскольку у результата запроса формат jsonb, расположение ключей не имеет значения.

Правильный ответ

{
    "genre": "роман-эпопея",
    "title": "Война и мир",
    "author": "Толстой Л.Н.",
    "published": 1985,
    "characters": [
        {
            "name": "Наташа Ростова",
            "dignity": "графиня"
        },
        {
            "name": "Пьер Безухов",
            "dignity": "граф"
        },
        {
            "name": "Андрей Болконский",
            "dignity": "князь"
        }
    ]
} 
Поскольку у результата запроса формат jsonb, расположение ключей не имеет значения.

Неправильный ответ

{
    "title": "Война и мир",
    "author": "Толстой Л.Н.",
    "published": 1985,
    "characters": [
        {
            "name": "Наташа Ростова",
            "dignity": "графиня"
        },
        {
            "name": "Пьер Безухов",
            "dignity": "граф"
        },
        {
            "name": "Андрей Болконский",
            "dignity": "князь"
        },
        {
            "genre": "роман-эпопея"
        }
    ]
} 
Присоединённый jsonb-объект может находиться в любом месте, но в объекте верхнего уровня, а не во вложенном массиве.

Будет ошибка запроса, потому что такого ключа нет в объекте json.
Этот запрос присоединяет новый jsonb-объект, поэтому не важно, существовал ли такой же ключ раньше.
Какой результат будет у такого запроса? Отметьте единственный верный вариант ответа.

SELECT '{"name": "Пьер Безухов"}'::jsonb <@ 
    '{
           "title": "Война и мир",
           "author": "Толстой Л.Н.",
           "published": 1985,
           "characters": [
              {
                  "name": "Наташа Ростова",
                  "dignity": "графиня"
              },
              {
                  "name": "Пьер Безухов",
                  "dignity": "граф"
              },
              {
                 "name": "Андрей Болконский",
                 "dignity": "князь"
              }
          ]
    }'::jsonb 


1
Результат оператора <@ — булево значение.


{
    "title": "Война и мир",
    "author": "Толстой Л.Н.",
    "published": 1985,
    "characters": [
        {
            "name": "Наташа Ростова",
            "dignity": "графиня"
        },
        {
            "dignity": "граф"
        },
        {
            "name": "Андрей Болконский",
            "dignity": "князь"
        }
    ]
} 
Результат оператора <@ — булево значение.

true
Проверяются только ключи верхнего уровня

Правильный ответ
false
Вхождение не будет найдено. Проверяются только ключи верхнего уровня, а предложенный элемент name — вложенный.
Какой результат будет у такого запроса? Отметьте единственный верный вариант ответа.

SELECT 
'{
        "title": "Война и мир",
        "author": "Толстой Л.Н.",
        "published": 1985,
        "characters": [
            {
                "name": "Наташа Ростова",
                "dignity": "графиня"
            },
            {
                "name": "Пьер Безухов",
                "dignity": "граф"
            },
            {
               "name": "Андрей Болконский",
               "dignity": "князь"
            }
        ]
    }'::jsonb ?| array['published', 'dignity'] 


[1985, "графиня", "граф", "князь"]
Результат оператора ?| — булево значение.

4
Результат оператора ?| — булево значение.

Правильный ответ
true
Результат равен true, если среди ключей верхнего уровня встречается хотя бы один элемент массива, в этом случае — published.

false
false получается, если среди ключей верхнего уровня не встречается ни одного элемента массива. В этом случае присутствует элемент published.
Какой результат будет у такого запроса? Отметьте единственный верный вариант ответа.

SELECT 
    '[
        {
            "name": "Наташа Ростова",
            "dignity": "графиня"
        },
        {
            "name": "Пьер Безухов",
            "dignity": "граф"
        },
        {
            "name": "Андрей Болконский",
            "dignity": "князь"
        }
    ]'::jsonb - 3 


Правильный ответ

[
     {
          "name": "Наташа Ростова",
          "dignity": "графиня"
     },
     {
          "name": "Пьер Безухов",
          "dignity": "граф"
     },
     {
          "name": "Андрей Болконский",
          "dignity": "князь"
     }
 ] 
В массиве нет элемента с индексом 3, значит, он останется неизменным.


[
     {
          "name": "Наташа Ростова",
          "dignity": "графиня"
     },
     {
          "name": "Пьер Безухов",
          "dignity": "граф"
     }
 ] 
Нумерация массива начинается с 0, следовательно, в нём нет элемента с индексом 3, и он останется неизменным.

Возникнет ошибка, потому что нет элемента с таким индексом.
Если в массиве нет элемента с указанным индексом, массив останется неизменным.

NULL
В массиве нет элемента с индексом 3, значит, ничего не будет удалено, и он останется неизменным.


