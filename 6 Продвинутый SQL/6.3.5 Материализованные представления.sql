Материализованные представления
В предыдущих уроках вы познакомились с обычными (простыми) представлениями, а также с обновляемыми представлениями и узнали, в каких ситуациях их можно применять. В этом уроке вы рассмотрите ещё один вид представлений — материализованные и попрактикуетесь создавать, изменять и удалять такие представления.
Используя представления, PostgreSQL каждый раз выполняет запрос, на основе которого это представление создано, с данными, актуальными на текущий момент. Если данные в базовых таблицах изменились, то и результат выборки из представления изменится.
Так работают обычные представления, но есть вид представлений, у которых «своя атмосфера» — это материализованные представления. Они записывают результат выборки на диск при создании и перезаписывают эти результаты только по определённой команде.
Материализованные представления отличаются от простых представлений только тем, что результат запроса SELECT сохраняется на диске.
Вот что получается: данные в таблицах меняются, а результат выборки материализованных представлений — в отличии от обычных — остаётся прежним, пока его не обновят.
Чаще всего, материализованные представления используют для различных отчётов, которые базируются на одних и те же данных.
Например, вы работаете в банке. Для простоты объяснения примера сильно упростим банковскую систему и представим, что банк работает так: в течении дня там происходит множество операций по счетам клиентов — переводы денег с одного счёта на другой, внесение денег на счёт, снятие наличных и другие. В конце дня нужно посчитать остаток денег на счетах клиентов после всех операций. На следующий день данные об этих остатках понадобятся для работы множеству отделов банка: бухгалтерии, отделу развития новых продуктов, отделу по взысканию просроченной задолженности и другим.
Посчитать остатки по состоянию на прошлый день можно независимо для каждого из отделов банка, но это долго и неудобно. Каждый раз вы будете считать один и тот же остаток на счёте каждого клиента. Поэтому можно сделать это один раз с помощью материализованного представления в конце рабочего дня и зафиксировать результаты запроса на диске. 
Дальше различные подразделения банка — от бухгалтерии до службы безопасности — могут обращаться к сохранённым данным на диске через материализованное представление, а не пересчитывать каждый раз одно и тоже.
Продуманное использование материализованных представлений может повысить производительность БД в целом. 
Например, есть сложный запрос, который выполняется долго — часами. Можно создать материализованное представление, которое будет сохранять результаты запроса периодически — например, раз в сутки. Результаты будут пересчитываться и перезаписываться. Дальше другие запросы используют эти сохранённые результаты. Запрос фактически выполнился один раз, а его результат используется множество раз, при этом извлекать из БД его можно максимально быстро.
Разберём, как создать, изменить, обновить и удалить материализованное представление, а затем вы попрактикуетесь делать это самостоятельно.
Создаём материализованное представление
Синтаксис создания материализованного представления почти не отличается от создания обычного представления — берёте команду DDL CREATE VIEW и добавляете ключевое слово MATERIALIZED:

CREATE MATERIALIZED VIEW имя_представления AS
    SELECT ...; 
Удаляем материализованное представление
Если оказалось, что представление больше не нужно, его можно удалить командой DROP VIEW, добавив ключевое слово MATERIALIZED:

DROP MATERIALIZED VIEW имя_представления; 
Изменяем материализованное представление
Если вам нужно изменить материализованное представление, используйте комбинацию из двух предыдущих команд DDL:

DROP MATERIALIZED VIEW имя_представления;
CREATE MATERIALIZED VIEW имя_представления AS
    SELECT ...; 
Также можно использовать команду ALTER MATERIALIZED VIEW, но её возможности ограничены. Например, с помощью этой команды можно переименовать представление:

ALTER MATERIALIZED VIEW имя_представления RENAME TO новое_имя_представления; 
но нельзя изменить запрос SELECT, на основе которого строится представление.
Подробно о возможностях этой команды можно прочитать в документации PosgreSQL.
В отличии от обычных представлений, материализованные нельзя изменить конструкцией CREATE VIEW OR REPLACE.
Обновляем материализованное представление
По умолчанию материализованные представления не обновляются автоматически при изменении базовых таблиц. Чтобы обновить материализованное представление, используют команду REFRESH MATERIALIZED VIEW. Она пересчитает данные представления на основе текущих данных из базовых таблиц. 

REFRESH MATERIALIZED VIEW имя_представления; 
PostgreSQL выполняет запрос SELECT представления и сохраняет результаты этого запроса на диске до следующей команды REFRESH MATERIALIZED VIEW. Если вы строите запросы на основе этого представления, то PostgreSQL будет использовать сохранённый результат запроса этого представления с диска.
Вы рассмотрели синтаксисы команд, теперь — попрактикуйтесь. 
Создайте материализованное представление на основе уже знакомой вам таблицы clients:

-- Создайте представление v_tmp_clients на основе базовой таблицы clients
CREATE MATERIALIZED VIEW v_tmp_clients AS
    SELECT
        id,
        fio,
        phone
    FROM clients; 
В навигаторе DBeaver v_tmp_clients появилось в списке материализованных представлений схемы public.

Выполните запрос на основе представления v_tmp_clients:

SELECT
    * 
FROM v_tmp_clients
ORDER BY id; 
И посмотрите результат выборки:
id	fio	phone
1	Иванов Иван Иванович	79990000001
2	Петров Петр Петрович	79990000002
3	Васильев Василий Васильевич	79990000004
Теперь внесите изменения в таблицу clients:

-- Добавьте тестовые данные в таблицу
INSERT INTO clients (fio, phone)
VALUES
    ('Платонов Платон Платонович', '79990000003');

-- Обновите запись с id равным 1
UPDATE clients SET fio = 'Леонидов Леонид Леонидович', phone = '79990000005'
WHERE id = 1;

-- Удалите запись с id равно 2
DELETE FROM clients WHERE id = 2; 
Выполните запрос на основе материализованного представления v_tmp_clients:

SELECT
    * 
FROM v_tmp_clients
ORDER BY id; 
И посмотрите результат выборки:
id	fio	phone
1	Иванов Иван Иванович	79990000001
2	Петров Петр Петрович	79990000002
3	Васильев Василий Васильевич	79990000004
Как видите — результат запроса на основе материализованного v_tmp_clients не изменился. Потому что результат запроса SELECT был записан на диск в момент создания, и при внесении изменений в базовую таблицу clients данные на диске материализованного представления не изменились.
Теперь обновите материализованное представление v_tmp_clients и посмотрите результат прошлого запроса:

-- Обновите материализованное представление
REFRESH MATERIALIZED VIEW v_tmp_clients;

-- Посмотрите результат выборки материализованного представления
SELECT
    * 
FROM v_tmp_clients
ORDER BY id; 
Результат запроса изменится:
id	fio	phone
1	Леонидов Леонид Леонидович	79990000005
3	Васильев Василий Васильевич	79990000004
4	Платонов Платон Платонович	79990000003
В таблицу clients из прошлого примера добавили ещё одного клиента — Сидорова Сидора Сидоровича.
После этого запустили запрос ниже.

SELECT COUNT(*)
FROM v_tmp_clients; 
Какой результат вернёт такой запрос?
Напишите свой вариант в поле ниже:
Ваш ответ неправильный

старую таблицу

Если бы представление v_tmp_clients было бы нематериализованным, то результат был бы 4, так как изменение данных в таблице clients изменило бы и результат запроса. Материализованное представление v_tmp_clients в момент создания записало на диск результат запроса 3 и до команды REFRESH результат менять не будет.


