Функции ранжирования. ROW_NUMBER()
В прошлых уроках вы работали с агрегирующими оконными функциями. Теперь перейдём к другой группе оконных функций — к функциям общего назначения. В этом уроке вы познакомитесь с функциями ранжирования. 
Функции ранжирования — это функции, которые присваивают строкам таблицы порядковые номера, или ранги. 
Ранжировать строки можно как в целом по всей таблице, так и отдельно по различным сегментам или параметрам. Ранжирование помогает пронумеровать строки и составить рейтинги, например:
последовательно пронумеровать строки в таблице;
пронумеровать заказы или действия пользователей по мере их совершения;
составить список пользователей по убыванию значения среднего чека;
ранжировать рекламные каналы по затраченному бюджету;
составить список страниц веб-приложения с высоким временем загрузки в зависимости от типа устройства.
Казалось бы, составить рейтинги можно и с помощью ORDER BY. Но использовать данные такого рейтинга неудобно. Скажем, если нужно сравнить между собой чеки за третий, седьмой и двенадцатый рабочий день каждого месяца, без поля с номером ранга обойтись будет сложно.
В курсе вы познакомитесь с оконными функциями ранжирования ROW_NUMBER(), RANK, DENSE RANK.

Функция ROW_NUMBER() присваивает порядковый номер строкам с учётом той последовательности, в которой они записаны в таблице. Каждая запись получает уникальный номер. 
Разберём работу этой функции на примере выборки заказов, совершённых тремя пользователями из данных таблицы online_store.orders.
Описание схем онлайн-магазина «Сила — в окнах»


SELECT *
FROM online_store.orders
WHERE user_id IN (300768196, 840452722, 59432616); 
user_id	event_dt	revenue
59432616	2020-06-17	7.59
840452722	2020-06-19	5.81
840452722	2020-06-21	3.17
840452722	2020-06-24	6.27
300768196	2020-06-25	8.74
300768196	2020-06-27	5.26
Записи в таблице хранятся по времени совершения заказа. Функция ROW_NUMBER() поможет присвоить каждому заказу порядковый номер. Результат войдёт в отдельное поле. Обратите внимание, что ROW_NUMBER() не требует аргумента — значения, которое передают функциям. 

SELECT *,
    ROW_NUMBER() OVER ()
FROM online_store.orders 
WHERE user_id IN (300768196, 840452722, 59432616); 
user_id	event_dt	revenue	row_number
59432616	2020-06-17	7.59	1
840452722	2020-06-19	5.81	2
840452722	2020-06-21	3.17	3
840452722	2020-06-24	6.27	4
300768196	2020-06-25	8.74	5
300768196	2020-06-27	5.26	6
Записи проранжированы в том порядке, в котором они записаны в таблице, и каждая запись получила свой порядковый номер, или ранг. Если добавить в запрос оператор ORDER BY, который изменит порядок записей, каждая запись сохранит первоначальный ранг. Это связано с тем, что по порядку выполнения запросов часть SELECT отрабатывает раньше, чем ORDER BY.

SELECT *,
    ROW_NUMBER() OVER ()
FROM online_store.orders 
WHERE user_id IN (300768196, 840452722, 59432616)
ORDER BY user_id; 
user_id	event_dt	revenue	row_number
59432616	2020-06-17	7.59	1
300768196	2020-06-25	8.74	5
300768196	2020-06-27	5.26	6
840452722	2020-06-19	5.81	2
840452722	2020-06-21	3.17	3
840452722	2020-06-24	6.27	4
Обратите внимание, что функция ROW_NUMBER() пронумеровала записи в зависимости от их порядка в таблице. Ранжировать записи можно и по-другому. 
Задаём порядок ранжирования
Чтобы задать другой порядок, в выражение OVER добавляют оператор ORDER BY вместе с полем, по которому нужно ранжировать записи. 
Например, такой запрос проранжирует записи в зависимости от user_id — от меньшего к большему:

SELECT *, 
    ROW_NUMBER() OVER (ORDER BY user_id)
FROM online_store.orders 
WHERE user_id IN (300768196, 840452722, 59432616)
ORDER BY user_id; 
user_id	event_dt	revenue	row_number
59432616	2020-06-17	7.59	1
300768196	2020-06-25	8.74	2
300768196	2020-06-27	5.26	3
840452722	2020-06-19	5.81	4
840452722	2020-06-21	3.17	5
840452722	2020-06-24	6.27	6
Ранжировать записи можно не только по возрастанию значений в поле, но и по убыванию. Для этого можно использовать ключевое слово DESC. Если указать ASC, записи будут проранжированы по возрастанию — так же, как и по умолчанию. 

SELECT *, 
    ROW_NUMBER() OVER (ORDER BY user_id DESC)
FROM online_store.orders
WHERE user_id IN (300768196, 840452722, 59432616)
ORDER BY user_id; 
user_id	event_dt	revenue	row_number
59432616	2020-06-17	7.59	6
300768196	2020-06-25	8.74	4
300768196	2020-06-27	5.26	5
840452722	2020-06-19	5.81	1
840452722	2020-06-21	3.17	2
840452722	2020-06-24	6.27	3
Записи с совпадающими user_id получили разные ранги — по порядку расположения в таблице. Такая логика ранжирования подойдёт не для всех задач. Например, есть только один приз для первого места, или мы можем выполнить только один заказ от каждого пользователя. О том, как присвоить таким записям одинаковые ранги, расскажем в  следующих уроках.

Ранжируем по нескольким полям
В прошлом спринте вы узнали, что сортировать записи можно по нескольким полям сразу. 
Так же и в оконных функциях: выражение с оператором ORDER BY может содержать сразу несколько полей. 
Порядок, в котором указаны поля, определяет приоритет ранжирования.

SELECT *, 
    ROW_NUMBER() OVER (ORDER BY user_id, event_dt DESC)
FROM online_store.orders 
WHERE user_id IN (300768196, 840452722, 59432616)
ORDER BY user_id; 
user_id	event_dt	revenue	row_number
59432616	2020-06-17	7.59	1
300768196	2020-06-27	5.26	2
300768196	2020-06-25	8.74	3
840452722	2020-06-24	6.27	4
840452722	2020-06-21	3.17	5
840452722	2020-06-19	5.81	6


Запись с наименьшим user_id и с наибольшим значением event_dt получит ранг 1 — ведь так задано правило ранжирования. 
С помощью оконной функции ROW_NUMBER() и оператора ORDER BY можно выбрать запись с определённым рангом. 
Например, из таблицы online_store.sessions можно выбрать запись с рангом 100 в зависимости от даты сессии. 
Проранжированные записи можно поместить в общее табличное выражение, чтобы из него выбрать запись с нужным рангом. 

WITH sessions AS (
    SELECT *,
        ROW_NUMBER() OVER (ORDER BY session_start) AS rn
    FROM online_store.sessions
)
SELECT *
FROM sessions
WHERE rn = 100; 
user_id	region	device	channel	session_duration	session_start	rn
955216418279	Germany	Mac	Organic	13	2020-06-14 00:11:10	100
Ранжируем внутри каждого окна
В прошлых уроках вы изучали важную особенность оконных функций — действия можно выполнять внутри заданного окна.
Задать оператор окна можно с помощью PARTITION BY. Ранжировать данные также можно не по всей выборке, а по отдельным группам.
Проранжируем пользовательские заказы по каждой дате, то есть каждый день порядковые номера заказов будут начинаться с номера 1.

SELECT *, 
    ROW_NUMBER() OVER (PARTITION BY event_dt ORDER BY user_id )
FROM online_store.orders
WHERE user_id IN (1366418076, 1398251690, 59432616); 
user_id	event_dt	revenue	row_number
1366418076	2020-06-14	1.9	1
1398251690	2020-06-14	01.09	2
1366418076	2020-06-15	1.35	1
59432616	2020-06-17	7.59	1
1366418076	2020-06-17	3.21	2
1366418076	2020-06-19	7.19	1
Потренируйтесь ранжировать записи с помощью ROW_NUMBER() и ORDER BY в следующем уроке.