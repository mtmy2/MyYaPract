Функции для работы с массивами
В этом уроке вы продолжите изучать массивы в PostgreSQL: узнаете, как изменить элементы массива, и познакомитесь со специфическими функциями и операторами для работы с этим типом данных.
Это насыщенный урок, и, возможно, за один присест вы его не осилите — ничего страшного. Делайте перерывы и давайте себе передохнуть, если чувствуете, что устали. Кроме того, примеры будут на основе уже знакомой базы данных Taxi Online.
Обновляем данные массива
Начнём с примера. Представьте, что пассажир, который уже пользовался услугами агрегатора, при заказе указал новый дополнительный номер телефона. Нужно найти этого пассажира в таблице clients и обновить массив в поле add_phones — добавить в конец новый элемент. Помните, что идентифицируется клиент по основному номеру телефона.
Есть два способа добавить элемент в конец массива. 
Оператор || — используйте оператор конкатенации ||. По правую и левую сторону от оператора конкатенации должны стоять массивы.
Добавьте дополнительный номер телефона клиенту с основным номером 71112223344:

UPDATE taxi.clients SET add_phones = add_phones || '{"75553334455"}'
WHERE phone = '71112223344' 
В этом случае добавляемый номер телефона передаётся как массив из одного элемента. 
Можно поменять массивы местами, и тогда новый элемент вставится не в конец, а в начало массива:

UPDATE taxi.clients SET add_phones = '{"72228886655"}' || add_phones
WHERE phone = '71112223344' 
Функция ARRAY_APPEND — используйте функцию ARRAY_APPEND(массив, добавляемый элемент).
Добавьте новый номер для клиента с основным номером телефона 73332221144:

UPDATE taxi.clients SET add_phones = ARRAY_APPEND(add_phones, '71112223344')
WHERE phone = '73332221144' 
Здесь новый номер телефона передаётся в формате строки, поскольку массив текстовый.
Проверьте, что массивы корректно обновились:

SELECT * FROM taxi.clients 
Также можно заменить конкретный элемент массива — для этого после названия массива в квадратных скобках указывают индекс заменяемого элемента. 
Например, показатели прибыли, полученной с таксопарка с id = 1, за понедельник пересчитали, и их нужно обновить:

UPDATE taxi.depots_economic_report SET economic_data[1][2] = 50 WHERE depot_id = 1 
Ещё можно заменить не один элемент, а целый диапазон или срез. Для этого после названия массива в квадратных скобках указывают [индекс нижней границы диапазона : индекс верхней границы диапазона]. Затем этому диапазону присваивают некий массив. 
Например, обновите первые два дополнительных номера телефона для клиента с основным номером 71112223344:

UPDATE taxi.clients SET add_phones[1:2] = '{"72228880000", "78885550000"}'
WHERE phone = '71112223344' 
Выполните SELECT из таблицы clients и убедитесь, что данные обновились корректно.
Ищем по значению в массиве
Если у поля таблицы тип данных — массив, неизбежно возникнет задача отфильтровать значения по какому-то условию. 
Например, в таблице depots_economic_report нужно найти все таксопарки, чья выручка за вторник была больше 300 000.
Вторник — второй день недели, а выручка — первый экономический показатель из двух. Поэтому индекс элемента, который нужно найти, такой: [2][1].
Теперь просто сравните этот элемент с 300:

SELECT * FROM taxi.depots_economic_report WHERE economic_data[2][1] > 300 
Другой пример — нужно найти клиентов по дополнительному номеру телефона. Индекс элемента, в котором встретится этот номер, заранее неизвестен. Для таких задач используют ключевое слово ANY.

SELECT * FROM taxi.clients WHERE '72228880000' = ANY(add_phones) 
Выделенная часть после WHERE буквально означает «72228880000 равно любому значению из колонки add_phones».
Для этой же выборки можно использовать другой способ — оператор &&. По левую и правую сторону у него — массивы, а результат — типа boolean. Он возвращает true, если массивы пересекаются, и false, если они не пересекаются:

SELECT * FROM taxi.clients WHERE add_phones && '{"72228880000"}' 
Если необходимо проверить на соблюдение условия не любой элемент массива, а все элементы одновременно, используют ключевое слово ALL.
Например, найдите таксопарки, у которых все экономические показатели за все дни больше 60 000. Для этого нужно взять каждый элемент двумерного массива и убедиться, что он больше 60. Здесь и используется ALL:

SELECT * FROM taxi.depots_economic_report WHERE 60 < ALL(economic_data) 
Условие WHERE означает «60 меньше всех элементов массива economic_data».
ALL и ANY в запросе всегда ставят справа от оператора сравнения.
А что, если нужно найти те таксопарки, у которых выручка за каждый из семи дней недели больше 150 000? Здесь для сравнения понадобится не весь массив economic_data, а только срез по выручке. Поскольку массив двумерный, используйте две пары квадратных скобок:

economic_data[][] 
Первая пара скобок — это строки массива, то есть дни. Вам нужны все дни, с первого по седьмой, поэтому запишите там срез:

economic_data[1:7][] 
В квадратных скобках обязательно должен быть указан элемент или диапазон. Если оставить их пустыми, запрос вернёт ошибку.
Вторая пара скобок — это индекс внутри одномерного массива. Вас интересует только выручка, а это первый элемент многомерного массива. В итоге запрос будет выглядеть так:

SELECT * FROM taxi.depots_economic_report WHERE 150 < ALL(economic_data[1:7][1]); 
Если мы захотим оценить только прибыль и узнать, превышала ли она 150 000 каждый день, после ключевого слова ALL вместо ссылки на первый элемент одномерного массива добавим ссылку на второй.
Заменим во вторых квадратных скобках 1 на 2. Запрос выдаст некорректный результат, так как будет сравнивать со 150 000 первые два элемента одномерного массива — и прибыль, и выручку.

SELECT * FROM taxi.depots_economic_report WHERE 150 < ALL(economic_data[1:7][2]); 
Выражение economic_data[1:7][2] аналогично economic_data[1:7][1:2], потому что [2] во вторых скобках по умолчанию означает диапазон от 1 до 2.
Чтобы использовать в сравнении только срез по прибыли, то есть только второй элемент одномерного массива, во вторых квадратных скобках используем диапазон [2:2]:

SELECT * FROM taxi.depots_economic_report WHERE 150 < ALL(economic_data[1:7][2:2]); 
Операторы для работы с массивами
При работе с массивами можно использовать различные операторы. Два из них: || и && — вы уже знаете.
Сравниваем. Бывает, необходимо сравнить два массива друг с другом. Для этого используют операторы = и <>.
Два массива равны, когда у них одинаковая размерность и равны все их элементы. Например, эти массивы равны:

SELECT ARRAY[1, 2, 3] = ARRAY[1, 2, 3] 
А эти — нет, потому что у них разная размерность: первый одномерный, а второй двумерный, в котором элементы второго одномерного массива не заданы.

SELECT ARRAY[1, 2, 3] = ARRAY[[1, 2, 3]] 
Эти массивы тоже не равны, поскольку элементы расположены не в одинаковом порядке:

SELECT ARRAY[1, 2, 3] = ARRAY[3, 2, 1] 
Оператор неравенства <> работает по тем же принципам:

SELECT ARRAY[1, 2, 3] <> ARRAY[1, 2, 3]; -- false
SELECT ARRAY[1, 2, 3] <> ARRAY[[1, 2, 3]]; -- true
SELECT ARRAY[1, 2, 3] <> ARRAY[3, 2, 1]; -- true 
Определяем вхождение. Ещё два полезных оператора — @> и его зеркальное отражение <@. Их применяют для определения вхождения одного массива в другой.
Считается, что один массив входит в другой, если все значения первого массива встречаются во втором.
Массив, указанный со стороны @, рассматривается как тот, в котором ищутся вхождения. Массив с другой стороны — тот, чьё вхождение проверяется. Другими словами, arr1 @> arr2 проверяет, что массив arr1 содержит значения массива arr2, а arr2 <@ arr1 проверяет, что массив arr2 содержится в массиве arr1.
Вот примеры проверки вложенности и их результаты:

-- true, все элементы второго массива встречаются в первом
SELECT ARRAY[1, 2, 3, 4, 5] @> ARRAY[5, 3];

-- false, второй массив не содержит все элементы первого
SELECT ARRAY[1, 2, 3, 4, 5] <@ ARRAY[5, 3];

-- true, второй массив содержит все значения первого
SELECT ARRAY[5, 3] <@ ARRAY[1, 2, 3, 4, 5]; 
Фух! Большая часть урока позади. Вы хорошо справляетесь. Можно запить булочку квасом, а затем приступать к квизам.
Есть таблица array_test, в ней два поля: id — идентификатор строки и arr_data — массив целых чисел. Вот как выглядит содержимое таблицы:
id	arr_data
1	{5,6,7,8,9,10}
2	{0,1,2,3,4,5}
3	{{3,4,5},{7,8,9}}
Изучите запросы ниже и выберите, какой результат они дадут. В каждом случае отметьте единственный верный вариант ответа.
SELECT '{1}' || arr_data FROM array_test WHERE id = 1


{5,6,7,8,9,10,1}
Новый элемент стоит слева от оператора ||, а значит, не может присоединяться в конец массива.

Правильный ответ
{1,5,6,7,8,9,10}
Новый элемент присоединяется в начало массива.

{5,6,7,8,9,11}
Оператор конкатенации склеивает значения массива, а не складывает их.

false
Результат конкатенации — массив, а не булево значение.
SELECT 10 < ANY(arr_data) FROM array_test WHERE id = 2


true
В массиве нет ни одного элемента больше десяти.

Правильный ответ
false
Все элементы массива {0,1,2,3,4,5} меньше десяти.

{10,0,1,2,3,4,5}
Оператор сравнения возвращает true или false.

{0,1,2,3,4,5,10}
Результат сравнения — булево значение.
SELECT id FROM array_test WHERE 6 > ALL(arr_data)


1
В массиве с id = 1 есть элементы больше шести.

Правильный ответ
2
Только в массиве с id = 2 все элементы меньше шести.

3
В массиве с id = 3 есть элементы больше шести.

Пустой результат
В таблице есть массив с id = 2, где все элементы меньше шести.
SELECT arr_data @> ARRAY[10, 5] FROM array_test WHERE id = 1


Правильный ответ
true
Все значения массива {10,5} встречаются в массиве {5,6,7,8,9,10}.

false
Все значения массива {10,5} встречаются в массиве {5,6,7,8,9,10}. Последовательность вхождения элементов не важна.

{5,6,7,8,9,10,10,5}
Результат оператора @> — true или false.

{6,7,8,9}
Результат оператора @> — true или false.
Почти конец. Остался последний рывок, и вы одолеете массивы!
Функции для работы с массивами
В PostgreSQL есть встроенные функции для работы с массивами. Рассмотрим те из них, которые с наибольшей вероятностью пригодятся вам в работе.
ARRAY_LENGTH
Эта функция возвращает длину массива. У неё два аргумента — сам массив и размерность, по которой определяют длину. Для одномерного массива это выглядит так:

SELECT ARRAY_LENGTH(ARRAY[1, 2, 3], 1) 
Для двумерного массива можно определить длину входящих в него одномерных массивов. Для этого в качестве второго аргумента передайте (запишите) 2:

SELECT ARRAY_LENGTH(ARRAY[[1, 2, 3], [4, 5, 6]], 2) 
Сравните результат:
array_length
3
Действительно, в обоих одномерных массивах по три элемента.
Определите размер самого «внешнего» массива. Для этого во второй аргумент передайте 1:

SELECT ARRAY_LENGTH(ARRAY[[1, 2, 3], [4, 5, 6]], 1)
 
Сравните результат:
array_length
2
В двумерном массиве два одномерных массива, значит, этот результат верен.
А вот практический пример этой функции из данных Taxi Online — определите, сколько дополнительных телефонов у каждого пользователя в таблице clients:

SELECT *, ARRAY_LENGTH(add_phones, 1) FROM taxi.clients 
Должна получиться такая таблица:
id	client_name	phone	add_phones	array_length
1	Лесной Анатолий Игоревич	71112223344	{72228880000,78885550000,73335556677,75553334455}	4
2	Полевой Александр Павлович	73332221144	{78881112233,77772224477,71112223344}	3
Попрактикуйтесь ещё — по таблице depots_economic_report определите, за сколько дней рассчитаны экономические показатели для таксопарков:

SELECT *, ARRAY_LENGTH(economic_data, 1) FROM taxi.depots_economic_report 
Сравните результат. В обеих записях в поле economic_data два одномерных массива, то есть данные за два дня.
id	depot_id	date_begin	economic_data	array_length
1	1	2023-08-04	{{350,90},{400,120}}	2
2	7	2023-08-04	{{350,90},{400,120}}	2
ARRAY_TO_STRING
Представьте, что нужно выводить в некоторую экранную форму все дополнительные телефоны пассажира через запятую и пробел. Для этого нужно отдавать из БД элементы массива, который хранится в add_phones, разделённые строкой ', '. Здесь пригодится функция array_to_string:

SELECT ARRAY_TO_STRING(add_phones, ', ') FROM taxi.clients WHERE id = 1 
В качестве разделителя для строки указаны запятая и пробел, но можно указать любые другие символы. Также в функцию array_to_string можно передавать третий аргумент, который будет проставляться в строке вместо элементов массива, имеющих значение NULL.
STRING_TO_ARRAY
Теперь представьте обратную ситуацию. Оператор записывает дополнительные телефоны пассажира в некоторое поле через запятую и пробел, и содержимое этого поля передаётся в базу данных в виде строки. Нужно вставить эти данные в таблицу clients, в поле add_phones в виде массива. Для этого используют обратную функцию — string_to_array:

UPDATE taxi.clients
SET add_phones = STRING_TO_ARRAY('72228880000, 78885550000', ', ')
WHERE id = 1 
Функция принимает два аргумента, первый из которых — строка, а второй — разделитель элементов массива. Также возможно передать третий аргумент — это будет строка, которая в результирующем массиве будет заменена на NULL.
UNNEST
Таксопарки, с которыми работает Taxi Online, ежедневно присылают ему список guid водителей, которые в этот день выходят на смены. Список поступает в виде массива значений, например такого:
['189ec08d-af9c-4f7f-a65c-d12c460d19eb', 'b9c2e818-bdbb-4cea-bd65-5f3b42782d80', 'cbdfac9f-5d95-4fbd-a081-11bddcf56dd5'].
Эти данные записывают в таблицу drivers_schedule, которая выглядит так:

CREATE TABLE taxi.drivers_schedule(
    id serial primary key,
    schedule_date date,
    depot_id integer,
    driver_guid uuid
) 
Нужен способ удобно и быстро вставлять данные из массива guid в таблицу drivers_schedule. В этой ситуации пригодится функция UNNEST. Она принимает в качестве аргумента массив и разворачивает его на набор строк. Например, так:

SELECT unnest(ARRAY['189ec08d-af9c-4f7f-a65c-d12c460d19eb',
    'b9c2e818-bdbb-4cea-bd65-5f3b42782d80',
    'cbdfac9f-5d95-4fbd-a081-11bddcf56dd5']) 
unnest (text)
189ec08d-af9c-4f7f-a65c-d12c460d19eb
b9c2e818-bdbb-4cea-bd65-5f3b42782d80
cbdfac9f-5d95-4fbd-a081-11bddcf56dd5
Чтобы вставить в таблицу данные, нужно получить значения типа uuid, поэтому придётся использовать явное приведение типов:

SELECT unnest(ARRAY['189ec08d-af9c-4f7f-a65c-d12c460d19eb',
    'b9c2e818-bdbb-4cea-bd65-5f3b42782d80',
    'cbdfac9f-5d95-4fbd-a081-11bddcf56dd5'])::uuid 
Оператор приведения :: сразу после закрывающей скобки функции UNNEST применяют, чтобы каждая полученная строка была преобразована к нужному типу.
Итак, id сгенерируется автоматически. schedule_date — это текущая дата, поскольку данные вставляют один раз в день. depot_id — это целое число, id таксопарка. Оно одинаково для всего массива, потому что от каждого таксопарка приходит один массив. 
Вот так можно лаконично записать INSERT с помощью оператора UNNEST:

INSERT INTO taxi.drivers_schedule(depot_id, driver_guid)
SELECT
    1, unnest(ARRAY[
        '189ec08d-af9c-4f7f-a65c-d12c460d19eb',
        'b9c2e818-bdbb-4cea-bd65-5f3b42782d80',
        'cbdfac9f-5d95-4fbd-a081-11bddcf56dd5'
    ])::uuid 
Готово:
id	schedule_date	depot_id	driver_guid
1	2023-08-10	1	189ec08d-af9c-4f7f-a65c-d12c460d19eb
2	2023-08-10	1	b9c2e818-bdbb-4cea-bd65-5f3b42782d80
3	2023-08-10	1	cbdfac9f-5d95-4fbd-a081-11bddcf56dd5
Вы разобрали несколько основных функций, полезных для работы с массивами. Остальные встроенные функции можно посмотреть на этой странице документации.
Есть таблица array_test, состоящая из двух полей: id — идентификатор строки и arr_data — массив целых чисел. Вот как выглядит её содержимое:
id	arr_data
1	{5,6,7,8,9,10}
2	{0,1,2,3,4,5}
3	{{3,4,5},{7,8,9}}
Изучите запросы ниже и выберите, какой результат они дадут. В каждом случае отметьте единственный верный вариант ответа.
SELECT ARRAY_LENGTH(arr_data, 1) FROM array_test WHERE id = 3


Правильный ответ
2
По логике запроса длину нужно вычислить по первому измерению, то есть посчитать количество одномерных массивов.

3
3 — это количество элементов в одномерном массиве для записи с id=3. В запросе длину нужно вычислить по первому измерению, то есть посчитать количество одномерных массивов.

6
6 — общее количество элементов двумерного массива. Длину нужно вычислить по первому измерению, то есть посчитать количество одномерных массивов.

1
Длину нужно вычислить по первому измерению двумерного массива {{3,4,5},{7,8,9}} , в нём два одномерных массива.
SELECT ARRAY_TO_STRING(arr_data, '***', '---') FROM array_test WHERE id = 2


0, 1, 2, 3, 4, 5
В качестве разделителя между элементами массива используют три звёздочки.

Правильный ответ
0***1***2***3***4***5
В качестве разделителя между элементами массива используют три звёздочки.

0---1---2---3---4---5
В качестве разделителя между элементами массива используют три звёздочки. Три дефиса — это замена элемента NULL, но в массиве такого элемента нет.

{0,1,2,3,4,5}
Результат функции ARRAY_TO_STRING — строка, состоящая из элементов массива и разделителей между ними.

