Функции смещения. LEAD(), LAG()
В этом уроке вы познакомитесь с функциями смещения LEAD() и LAG(). Функции смещения возвращают данные из других записей в зависимости от их расстояния от текущего значения. Например, стоимость предыдущего заказа или следующий раз, когда пользователь входил на сайт. 
Эти функции помогают проанализировать изменения параметров по сравнению с предыдущими значениями. Например, можно для каждого пользователя сравнить стоимость текущего заказа со стоимостью предыдущего — это поможет оценить динамику затрат. Или можно рассчитать время, прошедшее после совершения предыдущего заказа или любого другого действия — это поможет проследить пользовательский путь. 
Функция LAG() позволяет возвращать предыдущие записи, а LEAD() — следующие. Например, выведем для каждой записи с заказом пользователя дату прошлого или следующего заказа — previous_order_dt и next_order_dt соответственно.
Описание схем онлайн-магазина «Сила — в окнах»


SELECT 
    user_id,
    event_dt,
    LAG(event_dt) OVER (PARTITION BY user_id ORDER BY event_dt) AS previous_order_dt,
    LEAD(event_dt) OVER (PARTITION BY user_id ORDER BY event_dt) AS next_order_dt
FROM online_store.orders
WHERE user_id IN (300768196, 840452722, 59432616)
ORDER BY user_id; 
user_id	event_dt	previous_order_dt	next_order_dt
59432616	2020-06-17	[NULL]	[NULL]
300768196	2020-06-25	[NULL]	2020-06-27
300768196	2020-06-27	2020-06-25	[NULL]
840452722	2020-06-19	[NULL]	2020-06-21
840452722	2020-06-21	2020-06-19	2020-06-24
840452722	2020-06-24	2020-06-21	[NULL]
Синтаксис
Разберём синтаксис подробнее. У функций есть несколько аргументов:
LEAD(поле, смещение, значение по умолчанию) OVER (определение окна);
LAG(поле, смещение, значение по умолчанию) OVER (определение окна).
Аргумент поле указывает, из какого поля нужно вернуть значения. Аргумент смещение показывает, на какое количество строк относительно текущей должно произойти смещение. А значение по умолчанию указывает, какое значение нужно вернуть в случае, если нужной строки в таблице нет. 
В запросе выше функциям LEAD() и LAG() передали всего один аргумент — поле event_dt. Дело в том, что у двух других аргументов есть значения по умолчанию. Если не указать аргумент для смещения, он будет равен 1. В таком случае функции будут возвращать записи, которые находятся либо сразу за текущей записью, либо перед ней. 
Третий аргумент тоже можно не указывать — в этом случае функции по умолчанию вернут NULL, если нужного значения в поле нет.
Аргумент поле должен быть указан обязательно, иначе запрос вернёт ошибку.
ORDER BY в определении окна задаёт последовательность, по которой СУБД будет искать следующие или предыдущие значения. Если его не указывать, ошибки не будет, но значения будут выбраны в той последовательности, в которой они записаны в БД, поэтому результат может отличаться от ожидаемого.
Рассмотрим действие функций смещения подробней. Напомним, что функция LEAD() возвращает следующие записи относительно текущей. Аргументы 1 и NULL можно не указывать, и функции LEAD(event_dt, 1, NULL) и LEAD(event_dt) дадут одинаковые результаты. Если подставить в предыдущий код эти аргументы, то получим то же самое:

SELECT 
    user_id,
    event_dt,
    LEAD(event_dt, 1, NULL) OVER (PARTITION BY user_id ORDER BY event_dt) AS next_order_dt
FROM online_store.orders 
WHERE user_id IN (300768196, 840452722, 59432616)
ORDER BY user_id; 
user_id	event_dt	next_order_dt
59432616	2020-06-17	[NULL]
300768196	2020-06-25	2020-06-27
300768196	2020-06-27	[NULL]
840452722	2020-06-19	2020-06-21
840452722	2020-06-21	2020-06-24
840452722	2020-06-24	[NULL]
Поле next_order_dt хранит даты следующих заказов пользователей. Из результатов запроса видно, что пользователь с идентификатором 59432616 сделал всего один заказ, поэтому в поле next_order_dt вернулось значение NULL. 
Пользователь с идентификатором 300768196 сделал два заказа, поэтому в первой записи в поле next_order_dt указана дата второго заказа, а в следующей записи — NULL.
Описание иллюстрации — в тексте выше. 
![](https://pictures.s3.yandex.net/resources/2.10.1_1440border_1724860886.png)
*Image caption*
Дату предыдущего заказа можно выбрать аналогичным образом, но с помощью функции LAG():

SELECT 
    user_id,
    event_dt,
    LAG(event_dt) OVER (PARTITION BY user_id ORDER BY event_dt) AS previous_order_dt
FROM online_store.orders 
WHERE user_id IN (300768196, 840452722, 59432616)
ORDER BY user_id; 
user_id	event_dt	previous_order_dt
59432616	2020-06-17	[NULL]
300768196	2020-06-25	[NULL]
300768196	2020-06-27	2020-06-25
840452722	2020-06-19	[NULL]
840452722	2020-06-21	2020-06-19
840452722	2020-06-24	2020-06-21
 Посмотрите, как произойдёт смещение в этом случае:
Поле `previous_order_dt` хранит даты предыдущих заказов пользователей. Из результатов запроса видно, что пользователь с идентификатором `59432616` сделал всего один заказ, поэтому в поле `next_order_dt` вернулось значение `NULL`. 
Пользователь с идентификатором `300768196` сделал два заказа, поэтому во второй записи в поле `previous_order_dt` указана дата первого заказа, а в первой записи — `NULL`.
Ограничения аргументов функций LEAD() и LAG()
Отметим, что указывать аргумент для смещения нужно в типе integer. Отрицательные значения тоже можно использовать, но тогда функция LEAD() превратится в функцию LAG() и наоборот. Так делать не стоит, чтобы не нарушать логику работы функций. 
У аргумента для значения по умолчанию тоже есть ограничения — его нужно указывать в том же типе, что и остальные значения в поле, к которому применяют функцию. Применяя функцию смещения к полю event_dt, нельзя указать в качестве значения по умолчанию строку типа character, а значение типа date или NULL — можно. 
Смещение на две записи
Покажем, что будет, если сместить записи не на 1, а на 2. Изменим ещё и поведение функции в случае, если нужного значения нет. В предыдущем примере мы в этой ситуации записывали в поле NULL, а теперь в новое поле попадёт дата 2020-01-01.

SELECT 
    user_id,
    event_dt,
    LAG(event_dt, 2, '2020-01-01') OVER (PARTITION BY user_id ORDER BY event_dt) AS previous_order_dt
FROM online_store.orders 
WHERE user_id IN (300768196, 840452722, 59432616)
ORDER BY user_id; 
user_id	event_dt	previous_order_dt
59432616	2020-06-17	2020-01-01
300768196	2020-06-25	2020-01-01
300768196	2020-06-27	2020-01-01
840452722	2020-06-19	2020-01-01
840452722	2020-06-21	2020-01-01
840452722	2020-06-24	2020-06-19
Больше двух заказов оформил только один пользователь с идентификатором 840452722. В поле previous_order_dt вошла дата первого заказа из трёх — 2020-06-19. В остальных случаях в поле указана дата по умолчанию — 2020-01-01. 
Рассмотрим два примера применения функций смещения: рассчитаем время между событиями и вычислим прирост количества пользователей.
Например, можно определить, сколько дней прошло со дня предыдущего заказа пользователя. 

SELECT 
    user_id,
    event_dt,
    LAG(event_dt) OVER (PARTITION BY user_id ORDER BY event_dt) AS previous_order_date,
    event_dt - LAG(event_dt) OVER (PARTITION BY user_id ORDER BY event_dt) AS days_from_previous_order
FROM online_store.orders
WHERE user_id IN (300768196, 840452722, 59432616)
ORDER BY user_id; 
user_id	event_dt	previous_order_dt	days_from_previous_order
59432616	2020-06-17	[NULL]	[NULL]
300768196	2020-06-25	[NULL]	[NULL]
300768196	2020-06-27	2020-06-25	2
840452722	2020-06-19	[NULL]	[NULL]
840452722	2020-06-21	2020-06-19	2
840452722	2020-06-24	2020-06-21	3
Из даты заказа event_dt вычитается значение, рассчитанное с помощью функции LAG(), — дата предыдущего заказа. Если в PostgreSQL вычесть из одной даты другую, вернётся целое число, равное количеству дней между датами. 
Для первых заказов пользователей по-прежнему возвращается NULL, так как почти любая операция с NULL его же и возвращает.
Расчёт прироста пользователей
С помощью функций LEAD() и LAG() можно посчитать значения в сравнении с предыдущим или следующим периодом. Например, можно сравнить количество пользователей по дням недели: понедельник к понедельнику, вторник ко вторнику, среда к среде. Сначала нужно найти количество пользователей за каждый день:

SELECT 
    session_start::date AS session_date,
    COUNT(DISTINCT user_id) AS users_cnt
FROM online_store.sessions
GROUP BY session_date; 
Чтобы получить количество пользователей в этот же день недели, но семь дней назад, нужно указать смещение 7 в функции LAG(). 

WITH users_cnt AS (
    SELECT 
        session_start::date AS session_date,
        COUNT(DISTINCT user_id) AS users_cnt
    FROM online_store.sessions
    GROUP BY session_date
)
SELECT *,
    LAG(users_cnt, 7) OVER (ORDER BY session_date) AS previous_weekday_users_cnt
FROM users_cnt; 
session_date	users_cnt	previous_weekday_users_cnt
2020-06-14	10369	[NULL]
2020-06-15	13939	[NULL]
2020-06-16	17014	[NULL]
2020-06-17	19758	[NULL]
2020-06-18	19890	[NULL]
2020-06-19	19651	[NULL]
2020-06-20	19068	[NULL]
2020-06-21	18116	10369
2020-06-22	18766	13939
2020-06-23	21620	17014
Затем можно посчитать, во сколько раз увеличилось количество пользователей. Для этого нужно разделить число пользователей за текущий день на число пользователей семь дней назад. 

WITH users_cnt AS (
    SELECT 
        session_start::date AS session_date,
        COUNT(DISTINCT user_id) AS users_cnt
    FROM online_store.sessions
    GROUP BY session_date
)
SELECT *,
    LAG(users_cnt, 7) OVER (ORDER BY session_date) AS previous_weekday_users_cnt,
    users_cnt::numeric / LAG(users_cnt, 7) OVER (ORDER BY session_date) AS user_growth
FROM users_cnt; 
session_date	users_cnt	previous_weekday_users_cnt	user_growth
2020-06-14	10369	[NULL]	[NULL]
2020-06-15	13939	[NULL]	[NULL]
2020-06-16	17014	[NULL]	[NULL]
2020-06-17	19758	[NULL]	[NULL]
2020-06-18	19890	[NULL]	[NULL]
2020-06-19	19651	[NULL]	[NULL]
2020-06-20	19068	[NULL]	[NULL]
2020-06-21	18116	10369	1.74713
2020-06-22	18766	13939	1.34629
2020-06-23	21620	17014	1.27072
Если отнять от этого числа единицу и умножить на 100, получится прирост пользователей в процентах.

WITH users_cnt AS (
    SELECT 
        session_start::date AS session_date,
        COUNT(DISTINCT user_id) AS users_cnt
    FROM online_store.sessions
    GROUP BY session_date
)
SELECT *,
    LAG(users_cnt, 7) OVER (ORDER BY session_date) AS previous_weekday_users_cnt,
    ((users_cnt::numeric / LAG(users_cnt, 7) OVER (ORDER BY session_date)) - 1) * 100 AS user_growth
FROM users_cnt; 
session_date	users_cnt	previous_weekday_users_cnt	user_growth
2020-06-14	10369	[NULL]	[NULL]
2020-06-15	13939	[NULL]	[NULL]
2020-06-16	17014	[NULL]	[NULL]
2020-06-17	19758	[NULL]	[NULL]
2020-06-18	19890	[NULL]	[NULL]
2020-06-19	19651	[NULL]	[NULL]
2020-06-20	19068	[NULL]	[NULL]
2020-06-21	18116	10369	74.7131
2020-06-22	18766	13939	34.6295
2020-06-23	21620	17014	27.0718
В полях previous_weekday_users_cnt и user_growth с 15 по 20 июня указано значение NULL, ведь данных за прошлую неделю для этих записей нет. Чтобы это исправить, можно добавить другое значение по умолчанию в функцию LAG(), например, само значение users_cnt. В этом случае прирост будет равен нулю. 

WITH users_cnt AS (
    SELECT 
        session_start::date AS session_date,
        COUNT(DISTINCT user_id) AS users_cnt
    FROM online_store.sessions
    GROUP BY session_date
)
SELECT *,
    LAG(users_cnt, 7, users_cnt) OVER (ORDER BY session_date) AS previous_weekday_users_cnt,
    ((users_cnt::numeric / LAG(users_cnt, 7, users_cnt) OVER (ORDER BY session_date)) - 1) * 100 AS user_growth
FROM users_cnt; 
session_date	users_cnt	previous_weekday_users_cnt	user_growth
2020-06-14	10369	10369	0
2020-06-15	13939	13939	0
2020-06-16	17014	17014	0
2020-06-17	19758	19758	0
2020-06-18	19890	19890	0
2020-06-19	19651	19651	0
2020-06-20	19068	19068	0
2020-06-21	18116	10369	74.7131
2020-06-22	18766	13939	34.6295
2020-06-23	21620	17014	27.0718



