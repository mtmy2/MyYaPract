Взаимные блокировки
Ручные и автоматические блокировки в PostgreSQL — дело обычное и, как правило, работают без проблем. Однако бывают ситуации, когда несколько транзакций используют одни и те же ресурсы, но накладывают блокировки в разной последовательности. В таких случаях транзакции могут заблокировать друг друга. Это называется взаимная блокировка, или дэдлок (от англ. deadlock — мёртвая блокировка).
Такую проблему не решить очередью блокировок, единственный вариант — откатить (остановить) одну из транзакций. 
PostgreSQL постоянно мониторит взаимные блокировки в выполняющихся запросах, и когда находит их, завершает один из процессов, генерируя ошибку:
ERROR: deadlock detected 
Ошибка: выявлен дэдлок 
Заранее предсказать, какой именно процесс прервётся, а какой продолжит работать, — сложно, и повлиять на это не получится.
Если процесс, открывший прерванную транзакцию, умеет корректно обрабатывать такие ошибки, ничего страшного не произойдёт. Процесс просто запустит свой запрос заново, и, скорее всего, он выполнится успешно, потому что другая транзакция к тому моменту уже завершится либо захватит нужную блокировку, и дэдлока не возникнет.
Проблемы взаимных блокировок
Нет ничего идеального, и дэдлоки — не исключение. Вот какие трудности могут с ними возникнуть.
PostgreSQL не сразу устраняет взаимные блокировки, и какое-то время эти заблокированные транзакции просто висят, не делая ничего. Если в вашей системе одновременно работает множество небольших транзакций, где каждая секунда на счету, такое ожидание заблокированных транзакций может быть критично. Особенно если такие ситуации возникают часто.
Если транзакции оперируют большими объёмами данных — например, в аналитических системах, откат одной из них может занимать много времени и ресурсов сервера, а это снизит производительность всей системы.
Пока транзакция не прервётся, она уже успеет сделать какую-то часть своей работы, потратив ресурсы сервера впустую, — ведь эти изменения откатятся.
Пример взаимной блокировки
Создайте таблицу, в которой хранится информация об остатках средств у клиентов банка, и заполните её данными двух клиентов:

CREATE TABLE bank.balances(
    client_id INT,
    balance DECIMAL(10,2)
);

INSERT INTO bank.balances
VALUES
    (1, 1000.00),
    (2, 200.00);
 
Отлично! Теперь у клиента 1 на счету 1000 рублей, а у клиента 2 — 200 рублей.
Клиент 1 переводит 100 рублей клиенту 2. Для этого в транзакции сначала уменьшается остаток на счету клиента 1, а затем увеличивается на счету клиента 2.
Параллельно с этим в другой транзакции клиент 2 делает перевод 50 рублей клиенту 1. Процесс тот же — сначала уменьшается остаток средств на счету клиента 2, а потом увеличивается на счету клиента 1.
Выполните эти запросы поэтапно в двух разных вкладках своего менеджера БД.
Вкладка 1:

BEGIN;
UPDATE bank.balances
SET balance = balance-100
WHERE client_id = 1; 
Первая транзакция началась и обновила строку, автоматически наложив эксклюзивную блокировку на эту строку и разделяемую на саму таблицу.
Вкладка 2:

BEGIN;
UPDATE bank.balances
SET balance = balance-50
WHERE client_id = 2; 
Вторая транзакция началась и обновила строку, автоматически наложив эксклюзивную блокировку на эту строку и разделяемую на саму таблицу.
Вкладка 1:

UPDATE bank.balances
SET balance = balance+100
WHERE client_id = 2;
 
Первая транзакция попыталась изменить строку, уже заблокированную второй транзакцией, и встала в очередь, ожидая освобождения блокировки второй транзакцией.
Вкладка 2:

UPDATE bank.balances
SET balance = balance+50
WHERE client_id = 1;
 
Вторая транзакция пытается заблокировать строку, которую уже заблокировала первая транзакция.
В этот момент PostgreSQL обнаруживает взаимную блокировку и прерывает одну из транзакций. При этом в остановленной транзакции возникает ошибка ERROR: deadlock detected, а другая транзакция продолжает работать.
В тексте ошибки есть информация о типах блокировок и pid заблокированных транзакций:
ERROR: deadlock detected
DETAIL: Process 3560 waits for ShareLock on transaction 859; blocked by process 8604.
Process 8604 waits for ShareLock on transaction 860; blocked by process 3560.
HINT: See server log for query details.
CONTEXT: while updating tuple (0,1) in relation "balances" SQL state: 40P01 
Эта информация поможет выявить причины взаимных блокировок и устранить их.
Здесь причина дэдлока очевидна — транзакции блокируют одни и те же строки в противоположной последовательности, но взаимная блокировка бывает не только между двумя транзакциями, их может быть гораздо больше.
Вот как можно снизить вероятность взаимных блокировок в вашей системе:
Планирование транзакций. Если возможно, планируйте транзакции так, чтобы избегать ситуаций, когда несколько транзакций одновременно требуют доступа к одним и тем же ресурсам. Например, не запускайте одновременно несколько транзакций, меняющих одни и те же таблицы. Если транзакции выполняются автоматически, планируйте расписание их запусков на разное время.
Последовательность операций. Придерживайтесь одной и той же последовательности операций, работая с несколькими ресурсами. Это снизит вероятность взаимных блокировок. Например, в ситуации с изменением баланса по двум клиентам можно всегда первым выполнять UPDATE для строки с меньшим id клиента. Тогда в примере с изменением баланса во второй транзакции сначала бы выполнялся запрос для клиента с client_id = 1 , транзакция встала бы в очередь на эту строку и не помешала завершению первой транзакции, после чего выполнилась бы сама.
Тайм-ауты. Устанавливайте тайм-ауты на операции, это поможет избежать длительных блокировок. Если операция не может быть выполнена в течение определённого времени, она прерывается, и транзакция перезапускается или отменяется. В PostgreSQL тайм-аут задают с помощью параметра statement_timeout, подробнее о нём — в документации.
Сокращение времени блокировок. Сокращайте время, в течение которого ресурсы остаются заблокированными. Чем меньше время блокировки, тем ниже вероятность взаимных блокировок. Например, в длинных транзакциях явные блокировки можно накладывать не в самом начале транзакции, а перед непосредственным использованием блокируемого ресурса.
Обрабатывайте исключения, связанные со взаимными блокировками. Позаботьтесь о том, чтобы ваше приложение было готово обрабатывать исключения, связанные со взаимными блокировками, и при необходимости перезапускать транзакции.
Какая ситуация верно описывает взаимную блокировку? Выберите один вариант.


Все доступные ресурсы заняты и не могут освободиться.
При взаимной блокировке одни транзакции занимают ресурсы, необходимые для завершения других транзакций, которые в свою очередь блокируют ресурсы, необходимые для завершения первых транзакций. В итоге все эти транзакции не могут продолжить выполнение.

Правильный ответ
Несколько транзакций ожидают освобождения ресурсов, занятых друг другом, и не могут продолжить выполнение.
Транзакции блокируют ресурсы друг друга, из-за блокировки ни одна из них не может выполниться и освободить ресурсы.

Одна транзакция блокирует все ресурсы.
В случае, когда одна транзакция блокирует все ресурсы, они освобождаются сразу после её завершения. При взаимной блокировке несколько транзакций блокируют ресурсы друг друга и не могут продолжить выполнение.

Нет доступных ресурсов для блокировки.
При взаимной блокировке транзакции претендуют на одни и те же ресурсы, из-за чего они оказываются заблокированными разными транзакциями. При этом ни у одной из транзакций нет доступа ко всем необходимым ресурсам, поэтому она не может завершиться и освободить ресурсы для завершения других.
Как можно бороться с проблемами взаимных блокировок? Выберите все подходящие способы.


Не разрешать никому выполнять запросы к БД.
Это могло бы сработать, но тогда сама БД потеряет смысл.

Неправильный ответ
Установить настройку БД FIX DEADLOCK ON.
К сожалению, такой настройки не существует, хотя она, несомненно, осчастливила бы многих разработчиков.

Правильный ответ
Выполнять повторяющиеся в разных транзакциях операции в одном и том же порядке.
Это действительно может помочь.

Тоже правильный ответ
Не использовать одни и те же ресурсы в параллельных транзакциях.
Да, это сработает.


