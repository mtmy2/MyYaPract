Знакомство с представлениями
Представьте, что в сети магазинов сотовой связи есть таблица с данными обо всех продажах в сети. Вам нужно настроить разграничение доступа к данным из этой таблицы. Какой доступ к данным будет у сотрудника, зависит от его роли в компании. Продавцу нужен доступ только к собственным продажам, директору магазина важно видеть продажи всего магазина, а топ-менеджменту и службе безопасности нужен доступ ко всем продажам сети.
Предоставить разные права на таблицу не получится: в этом случае пользователь получает право доступа ко всей таблице и может читать её целиком, а вам нужно дать доступ лишь к части данных. В таких ситуациях помогут представления (от англ. view, поэтому в сленге разработчиков за представлением закрепилось прозвище «вьюха» или «вьюшка»).
В примере с магазином для каждого сотрудника будут разные фильтры — кто и что сможет видеть из исходной таблицы. Если вам когда-то приходилось настраивать отображение своих задач в общекомандной доске с задачами — так вот это тоже «вью».
В PostgreSQL представление — это псевдотаблица, сохранённый запрос SELECT к одной или нескольким таблицам. Упрощённо можно сказать так: представление — это любой запрос SELECT, которому дали уникальное имя.
Создание представлений
Создайте таблицу clients и заполните её данными пользователей с помощью скрипта ниже. Она пригодится вам во всех уроках этой темы.

/* Если таблица создана, удаляем её и пересоздаём.
Опция CASCADE поможет удалить не только сам объект,
но и все объекты, которые созданы на его основе. */
DROP TABLE IF EXISTS clients CASCADE;

CREATE TABLE clients (
    id SERIAL PRIMARY KEY, -- уникальный идентификатор
    fio CHARACTER VARYING, -- фамилия имя отчество пользователя
    phone CHARACTER VARYING, -- номер телефона пользователя
    address CHARACTER VARYING, -- адрес пользователя
    login CHARACTER VARYING, -- логин пользователя
    password CHARACTER VARYING -- пароль пользователя (обычно пароли 
    -- дополнительно хешируют, но для простоты запишем его в открытом виде)
);

-- Вставьте тестовые данные в таблицу с данными клиентов.
INSERT INTO clients (fio, phone, address, login, password)
VALUES
    ('Иванов Иван Иванович', '79990000001', 
     'г. Москва, Красная площадь, д. 1', 'IVANOV_II', 'tsartheterrible1530'),
    ('Петров Пётр Петрович', '79990000002', 
     'г. Санкт-Петербург, Сенатская площадь, д. 1', 'PETROV_PP', 'piterthegreat1672'),
    ('Васильев Василий Васильевич', '79990000004', 
     'г. Сочи, ул. Ленина, д. 1', 'VASILEV', 'vasiliytheblind2003'); 
Теперь выполните запрос SELECT к таблице clients.

SELECT
    id,
    fio,
    address,
    phone,
    'login: ' || login || '; password: ' || password AS login_password
FROM clients
WHERE fio = 'Иванов Иван Иванович'
    AND phone = '79990000001'; 
Чтобы создать представление на основе запроса SELECT, применяют команду раздела DDL (Data Definition Language, языка описания данных) CREATE VIEW. Её общий синтаксис такой:

CREATE VIEW имя_представления AS
    SELECT ... ; -- здесь можно подставить SELECT-запрос любой сложности 
Дайте запросу SELECT имя — clients_ivanov — и представление готово. 

CREATE VIEW clients_ivanov AS
SELECT
    id,
    fio,
    address,
    phone,
    'login: ' || login || '; password: ' || password AS login_password
FROM clients
WHERE fio = 'Иванов Иван Иванович'
    AND phone = '79990000001'; 
Чтобы создать представление в определённой схеме, нужно указать её в названии. Представления без указания схемы создаются в схеме public.
Проверьте, что в навигаторе DBeaver в списке представлений схемы public появилось clients_ivanov.
Скриншот показывает, что в списке представлений появилось `clients_ivanov`.
Запрос ниже создаст ещё одно представление clients_ivanov, но уже в схеме sandbox.

/*создаём схему sandbox, если она не была создана ранее*/
CREATE SCHEMA IF NOT EXISTS sandbox; 
/*создаём представление в схеме sandbox*/
CREATE VIEW sandbox.clients_ivanov AS
SELECT
    id,
    fio,
    address,
    phone,
    'login: ' || login || '; password: ' || password AS login_password
FROM clients
WHERE fio = 'Иванов Иван Иванович'
    AND phone = '79990000001'; 
Обратите внимание, что таблицы, используемые в представлении, и само представление не обязательно должны находится в одной схеме.
Представление — это псевдотаблица, поэтому само оно данных не содержит. Но можно использовать его в запросах как таблицу. Например, так:

SELECT
    id,
    login_password
FROM clients_ivanov; 
Таблицы и представления связаны: если вы измените данные в таблицах, к которым построен запрос SELECT, изменится результат выборки SELECT, а значит — результат выборки из представления тоже поменяется. 
Кроме обычных представлений, существуют ещё материализованные представления. Их логика и поведение отличаются от обычных. Материализованные представления вы изучите в следующих уроках.
Наименование представлений
Как видите, с точки зрения синтаксиса запроса SELECT базовая таблица и представление идентичны. Анализируя только запрос SELECT, вы не поймёте, что в нём используется — базовая таблица или представление.
Например:

SELECT
    id,
    fio,
    address
FROM clients
WHERE fio = 'Иванов Иван Иванович'; 
Что в этом запросе clients — таблица или представление? Неизвестно. Просто по наименованию в запросе ответить на этот вопрос невозможно. Поэтому в некоторых компаниях при наименовании представлений применяют так называемую венгерскую нотацию и используют префикс v_.

SELECT
    id,
    fio,
    address,
    phone
FROM v_clients; 
Если в запросе вы увидите наименование v_clients — с большой вероятностью это именно представление.
Пример выше — лишь один вариант использования представлений. Для инженеров или администраторов баз данных манипулирование таблицами — повседневная работа. Разработчики сервисов в крупных компаниях скорее будут запрашивать данные не напрямую через таблицы, а именно через представления. Помимо разграничения доступа, представления используют для других задач. Разберём, как ещё их применяют на практике.
Унифицируют запросы
Бывает, что один и тот же запрос используют в разных частях кода или разные клиенты БД. Допустим, одно поле этого запроса вычисляется на основе других полей. Вдруг кто-то заметил ошибку в вычислении. Значит — во всех местах, где используют этот запрос, необходимо его поменять. 
Хорошо, если запрос используют только в двух местах, а если в 202 местах — это уже становится проблемой. Исправить ошибку в коде в таком количестве мест при совместной разработке — сложно. Гораздо проще унифицировать запрос: дать ему уникальное имя и использовать запрос в виде представления там, где это необходимо. Если понадобится поменять запрос — поменяйте его в представлении и он автоматически изменится везде.
Скрывают реализацию
Как правило, сотрудникам компании нужны не сырые, а уже подготовленные данные: посчитанные, сгруппированные, переведённые на разные языки и так далее. Поэтому запрос бывает сложным и громоздким — работать с ним неудобно. В такой ситуации можно дать запросу имя и запрашивать данные только по этому имени. Для клиента, который запрашивает данные, это будет максимально простой запрос, а вся сложная внутренняя реализация запроса на сервере будет скрыта.
Управляют доступом к данным
Мошенники используют номера телефонов, чтобы получить доступ к личным данным, а с их помощью — доступ к финансам. Зачастую номера телефонов, логины и пароли в прямом или зашифрованном виде хранят в тех же таблицах, что и ФИО, дату рождения, адрес и другие базовые данные о пользователе, к которым есть доступ у разных отделов. 
С точки зрения безопасности хранение всех данных в общем доступе — потенциальный источник утечки информации. Чтобы снизить риск утечки, каждый из отделов должен получать ровно столько данных, сколько ему нужно, — ни больше, ни меньше необходимого. 
В таких случаях создают разные представления для разных отделов и каждому дают права на чтение только необходимых ему представлений. В каждом из этих представлений может быть свой набор полей после SELECT и разные условия после WHERE.
Разберём ситуацию на основе базовой таблицы данных пользователей clients и двух отделов компании — клиентов БД. 
клиентский сервис USER_INFO — отображает общие данные по клиенту. Доступ к: id, ФИО и телефону.
сервис идентификации AUTHENTICATION — проверяет логин и пароль клиента. Доступ к: исключительно логину и паролю пользователя.
У обоих клиентов не будет прав на чтение таблицы clients, но каждый клиент получит права на созданное для него представление:
v_clients_user_info для USER_INFO.
v_clients_authentication для AUTHENTICATION.
Иллюстрация текста выше

У каждого отдела доступ только к необходимым данным через своё представление


