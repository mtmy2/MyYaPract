Изменение данных в исходных таблицах через представления
В предыдущих уроках вы использовали представления только для чтения данных и могло сложиться впечатление, что это единственное применение представлений в PostgreSQL. На самом деле через представления можно изменять данные в исходных таблицах с помощью команд DML (Data Manipulation Language, языка манипулирования данными) INSERT, UPDATE и DELETE. Этим вы и займётесь в новом уроке.
Продолжим разбирать представления на уже знакомом примере. Есть два клиента БД AUTHENTICATION и USER_INFO, у них есть доступ к таблице clients, и каждый может читать таблицу через своё представление.
Вспомним, что клиенты БД — это отделы компании, каждый из них на каком-то уровне занимается пользователями. Представьте, что появился новый пользователь или старый пользователь решил изменить пароль или личные данные. Значит, у клиентов должна быть возможность добавлять, изменять или удалять записи о пользователях в таблице clients, но при этом у них нет доступа к самой таблице, поэтому они не могут изменять данные в таблице напрямую. Всё это можно делать через представления.
Представления, которые позволяют модифицировать данные в базовых таблицах, называются (автоматически) обновляемые представления (англ. automatically updatable view). Также их называют (автоматически) модифицируемые представления или (автоматически) изменяемые представления. В работе вы можете услышать любой из этих терминов и применять также любой — это синонимы. Так много названий получилось потому, что у английского термина нет устоявшегося перевода на русский язык.
Вы продолжите работать с таблицей клиентов clients, но слегка её измените: вместо поля address нужно сделать внешний ключ address_id. Это поможет увидеть ограничения обновляемых представлений, разберём их далее в уроке.
Кроме того, нужно создать ещё одну таблицу — addresses с адресами клиентов. 
Таблицы clients и addresses связаны отношением «один ко многим» — это значит, что один и тот же адрес может быть у нескольких разных пользователей. 

/* Если таблица создана, удалите её и пересоздайте.
Опция CASCADE поможет удалить не только сам объект,
но и все объекты, которые созданы на его основе. */
DROP TABLE IF EXISTS clients CASCADE;
DROP TABLE IF EXISTS addresses CASCADE;

-- Создайте таблицу с адресами
CREATE TABLE IF NOT EXISTS addresses (
    id SERIAL PRIMARY KEY, -- уникальный идентификатор
    location CHARACTER VARYING
);

-- Создайте таблицу с данными клиентов
CREATE TABLE IF NOT EXISTS clients (
    id SERIAL PRIMARY KEY, -- уникальный идентификатор
    fio CHARACTER VARYING, -- ФИО клиента
    phone CHARACTER VARYING, -- номер телефона клиента
    address_id INTEGER REFERENCES addresses(id), -- id адреса клиента
    login CHARACTER VARYING, -- логин клиента
    password CHARACTER VARYING -- пароль клиента
);

-- Вставьте тестовые данные в таблицу с адресами
INSERT INTO addresses (location)
VALUES
    ('г. Москва, Красная площадь, д. 1'),
    ('г. Санкт-Петербург, Сенатская площадь, д. 1'),
    ('г. Сочи, ул. Ленина, д. 1');

-- Вставьте тестовые данные в таблицу с данными клиентов
INSERT INTO clients (fio, phone, address_id, login, password)
VALUES
    ('Иванов Иван Иванович', '79990000001', 1, 'IVANOV_II', 'tsartheterrible1530'),
    ('Петров Пётр Петрович', '79990000002', 2, 'PETROV_PP', 'piterthegreat1672'),
    ('Васильев Василий Васильевич', '79990000004', 3, 'VASILEV_VV', 'vasiliytheblind2003'); 
Теперь на основе таблицы clients создайте представления:
v_clients_user_info — для клиентского сервиса USER_INFO,
v_clients_authentication — для сервиса идентификации AUTHENTICATION.
подобно тому, как делали в прошлых уроках:

-- Представление для сервиса USER_INFO
CREATE VIEW v_clients_user_info AS
    SELECT
        id,
        fio,
        phone,
        address_id
    FROM clients;

-- Представление для сервиса AUTHENTICATION
CREATE VIEW v_clients_authentication AS
    SELECT
        id,
        login,
        password
    FROM clients; 
Не все представления могут быть обновляемыми. Чтобы через представление можно было модифицировать данные в исходной таблице, оно должно соответствовать определённым требованиям.
Требования к обновляемым представлениям
Главный принцип такой: обновляемое представление должно быть максимально простым. 
Чтобы представление было обновляемым, ему нужно соответствовать таким требованиям:
После FROM указан только один элемент: таблица или другое обновляемое представление. Обновляемые представления не могут быть построены более чем на одной базовой таблице.
Представление не содержит группировку или ограничение выборки. Здесь логика такая: любая группировка: WITH, DISTINCT, GROUP BY, HAVING или ограничение выборки типа LIMIT, OFFSET усложняет запрос и через такое представление можно читать данные, но нельзя изменять.
Например, вы создали такое представление:

      -- Представление с группировкой
      CREATE VIEW v_clients_group AS
          SELECT
              max(id) AS id,
              fio,
              max(phone) AS phone,
              max(address_id) AS address_id
          FROM clients
          GROUP BY fio;
       
Если применить к этому представлению команду INSERT, она попытается вставить запись в сгруппированные данные, а это не имеет смысла. Потому что таблица выводит значение по группам — невозможно вставить данные в исходную таблицу, если есть информация только о группе в целом, но не о её элементах.
Команды UPDATE и DELETE попытаются соответственно изменить и удалить конкретную запись в таблице через сгруппированные данные. Для этого PostgreSQL каким-то образом нужно разгруппировать данные из запроса, а такой функции у СУБД нет.
Представление не содержит функций: агрегатных, оконных или возвращающих множества. Логика как с группировкой — функции усложняют запрос.
Представление не содержит операции со множествами: UNION, INTERSECT или EXCEPT. Та же логика — такие операции усложняют запрос.
  Разберём пример представления:

  -- Представление с объединением
  CREATE VIEW v_clients_union AS
      SELECT
          id,
          fio,
          phone,
          address_id
      FROM clients
      WHERE id >= 100 -- записи id равно и более 100
      UNION ALL
      SELECT
          id,
          fio,
          phone,
          address_id
      FROM clients
      WHERE id < 100; -- записи id менее 100
  
   
Кажется, что результаты выборки представления v_clients_union и представления v_clients_user_info не отличаются и можно каждую запись из представления соотнести с единственной записью в таблице clients. Однако UNION делает такое представление необновляемым.
Теперь посмотрите на обновляемые представления v_clients_user_info и v_clients_authentication, которые вы создали выше, — они максимально простые. Они просто повторяют поля таблицы clients, но каждое представление содержит только свой необходимый набор полей, а на поля в таблице clients не наложены ограничения NOT NULL, кроме первичного ключа.
Теперь, когда вы знаете, какие требования нужно соблюсти, разберём команды UPDATE и INSERT для обновляемых представлений.
UPDATE
UPDATE можно применить только к простым полям нижележащей таблицы или представления. Если поле в представлении определено с использованием констант или вычисляемых выражений, такое поле нельзя будет обновить.
Например, вы создали представление с константами, строками и выражениями:

-- Представление с константами, строками и выражениями
CREATE VIEW v_clients_exp AS
    SELECT
        id,
        'Иванов Иван Иванович' AS fio,
        phone || '' AS phone,
        1 AS address_id,
        login,
        password
    FROM clients; 
В представлении v_clients_exp:
поле fio определено как строка 'Иванов Иван Иванович',
поле phone определено как выражение phone || '',
поле address_id определено как константа 1.
В операции UPDATE нельзя использовать поля fio, phone, address_id, но можно использовать поля login, password, потому что они определены как поля таблицы clients.

-- Использование представления v_clients_exp в операции UPDATE
UPDATE v_clients_exp
    SET login = 'qwerty', password = '123'
WHERE id = 1; 
INSERT
Для INSERT представление должно содержать все поля основной таблицы, у которых есть ограничение NOT NULL и нет значения по умолчанию.
Нельзя вставить значение поля в таблицу, если это поле, с одной стороны, не может быть пустым, а с другой стороны, не объявлено в представлении, ведь в этом случае непонятно, какое значение нужно туда вставлять. Если в таблице есть ограничение на поле NOT NULL и у него нет значения по умолчанию, но в представление это поле не включено, то операцию INSERT для этого представления использовать не получится — запрос вернёт ошибку.
Запомнить требования к обновляемым представлениям поможет шпаргалка — скачайте её под катом.
Каким должно быть обновляемое представление


Теперь попробуем на практике применять команды DML INSERT, UPDATE и DELETE к обновляемым представлениям.
Потренируйтесь манипулировать данными через таблицу clients. Выполните все запросы в своем менеджере БД, убедитесь, что все операции проходят без ошибок и предсказуемо меняют данные в таблице clients.
Запрос ниже изменяет данные в таблице clients. Синтаксис таких запросов вы изучали в прошлом спринте.

INSERT INTO clients (fio, phone, address_id)
    VALUES ('ФИО нового клиента', '79012344444', 1);

-- проверьте, что в таблице пояивлась новая запись
SELECT * FROM clients

UPDATE clients SET fio = 'Фамилия Имя Отчество', phone = null
    WHERE fio = 'ФИО нового клиента';

-- проверьте, что запись в таблице изменена
SELECT * FROM clients

DELETE FROM clients
    WHERE phone is null;
    
-- проверьте, что запись удалена из таблицы
SELECT * FROM clients
 
Общий синтаксис запроса с обновляемыми представлениями такой же, как для таблиц. Просто поменяйте имя таблицы clients на имя обновляемого представления v_clients_user_info: 

INSERT INTO v_clients_user_info  (fio, phone, address_id)
    VALUES ('ФИО нового клиента', '79012344444', 1);
    
-- проверьте, что в таблице clients появилась новая запись
SELECT * FROM clients

UPDATE v_clients_user_info SET fio = 'Фамилия Имя Отчество', phone = null
    WHERE fio = 'ФИО нового клиента';
    
-- проверьте, что запись в таблице clients изменена
SELECT * FROM clients

DELETE FROM v_clients_user_info
    WHERE phone is null;
    
-- проверьте, что запись удалена из таблицы clients
SELECT * FROM clients 
Задание
Используя обновляемое представление v_clients_authentication, внесите изменения в таблицу clients:
добавьте клиента с логином sergeev_ss и паролем qwerty,
у клиента с логином PETROV_PP поменяйте пароль на piterthegreat1673,
удалите клиента с логином VASILEV_VV.
Код

PYTHON

1
INSERT INTO v_clients_authentication  (Login, password)
2
    VALUES ('sergeev_ss', 'qwerty');
3
    
4
UPDATE v_clients_authentication SET password = 'piterthegreat1673'
5
    WHERE login = 'PETROV_PP';
6
​
7
DELETE FROM v_clients_authentication
8
    WHERE login = 'VASILEV_VV';
9
​
10
​
11
​
Отлично! Обновили записи, не используя таблицу.


Подсказка



Проверить
Результат

В результате выполнения запроса нет данных для визуализации
Теперь попробуйте использовать представление v_clients_authentication, чтобы вставить, изменить или удалить запись через поля fio, phone и address_id, которых не было при определении самого представления:


INSERT INTO v_clients_authentication (fio, phone, address_id, login, password)
    VALUES ('ФИО нового клиента', '79012344444', 1, 'fio', '123');

UPDATE v_clients_authentication SET phone = '111'
    WHERE login = 'ФИО нового клиента';

DELETE FROM v_clients_authentication
    WHERE address_id= 1; 
Ничего не получится — запрос вернёт ошибку наподобие такой:
SQL Error [42703]: ERROR: column "fio" of relation "v_clients_authentication" does not exist 
Ошибка говорит, что поле fio не существует в используемом представлении v_clients_authentication.
Если вы не задали какие-то поля при создании представления, вы не можете использовать эти поля, чтобы вставлять, редактировать или удалять записи в этих полях в базовой таблице.
Подведём итог разобранного примера. Есть базовая таблица clients, к которой обращаются два разных клиента: AUTHENTICATION и USER_INFO. У этих клиентов нет прав на чтение и изменение базовой таблицы clients, но есть права на чтение и изменение базовой таблицы через представления v_clients_authentication и v_clients_user_info соответственно. Клиенты читают и изменяют только те данные, которые им необходимы, а данные, которые им не нужны, они не могут ни прочитать, ни изменить.

