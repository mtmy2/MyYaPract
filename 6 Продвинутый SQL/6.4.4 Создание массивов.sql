Создание массивов
В прошлом уроке вы вспомнили, что такое массивы, и узнали, какие особенности у них есть в SQL. В этом уроке вы продолжите работать с ними и потренируетесь создавать одномерные и многомерные массивы, а также вставлять и читать данные из массивов. 
Разбирать массивы продолжим на примере базы данных агрегатора Taxi Online.
Создаём одномерный массив
Вы также можете услышать термин «объявить массив»: создать и объявить массив — синонимы, вы можете использовать любой удобный вам термин.
Создайте таблицу пассажиров, которые пользуются услугами агрегатора, и назовите её clients. Таблица хранит первичный ключ id, имя клиента client_name, основной телефон клиента в поле phone и массив дополнительных номеров телефонов в поле add_phones:

CREATE TABLE taxi.clients (
    id integer PRIMARY KEY,
    client_name text,
    phone text,
    add_phones text[] -- массив текстовых данных
) 
При объявлении (создании) поля с типом данных «массив» используют указание типа данных элементов массива (здесь это text) и квадратные скобки [].
Несмотря на то что размер массива в PostgreSQL не ограничен, можно при создании таблицы в квадратных скобках явно указать размер — это не приведёт к синтаксической ошибке:

CREATE TABLE taxi.clients (
    id integer PRIMARY KEY,
    client_name text,
    phone text,
    add_phones text[3]  -- массив текстовых данных из трёх элементов
); 
Вместо квадратных скобок можно использовать ключевое слово ARRAY:

CREATE TABLE taxi.clients (
    id integer PRIMARY KEY,
    client_name text,
    phone text,
    add_phones text ARRAY -- массив текстовых данных
); 
Также можно указать, что массив состоит из трёх элементов:

CREATE TABLE taxi.clients (
    id integer PRIMARY KEY,
    client_name text,
    phone text,
    add_phones text ARRAY[3] -- массив текстовых данных из трёх элементов
); 
Однако фактически это не ограничивает размер массива — если вы попробуете вставить в это поле массив из четырёх элементов, он вставится успешно.
Создаём многомерный массив
Рассмотрим пример многомерного массива. Каждую неделю руководству Taxi Online нужен отчёт по каждому таксопарку, с которым они работают. В отчёте должны быть такие данные в разрезе дней недели: 
Выручка таксопарка — сумма всех оплат от пассажиров.
Прибыль с таксопарка — сумма, которую получит Taxi Online из выручки, за минусом выплат водителю, таксопарку и прочих расходов.
Допустим, что БД агрегатора большая, у неё существенная круглосуточная загрузка и построение отчёта один раз в неделю занимает много времени. 
Чтобы оптимизировать процесс, можно каждый день сохранять значения [выручка, прибыль] в отдельную таблицу depots_economic_report. 
[выручка, прибыль] — это одномерный массив. Всего таких массивов за неделю будет семь, то есть их можно объединить в многомерный массив. Зная дату начала недели, можно понять, к какой дате относится каждая пара значений.
Таблица со столбцами «Выручка» и «Прибыль». Слева дни недели. Значения выручки + прибыли по дням недели — это одномерный массив. Вся таблица — многомерный массив

Многомерный массив с данными по выручке и прибыли за неделю
Многомерный массив также объявляют с помощью квадратных скобок. При этом PostgreSQL, как и в случае с размером массива, никак не ограничивает количество измерений. 
Можно объявить многомерный массив точно так же, как одномерный:

CREATE TABLE taxi.depots_economic_report(
    id integer PRIMARY KEY,
    depot_id integer,
    date_begin date,
    economic_data integer[]
); 
Или использовать несколько пар квадратных скобок — столько, сколько измерений предполагается в массиве:

CREATE TABLE taxi.depots_economic_report(
    id integer PRIMARY KEY,
    depot_id integer,
    date_begin date,
    economic_data integer[][]
); 
Также можно указать размер массива по каждому измерению. 
В примере выше, чтобы найти экономический показатель, сначала нужно указать день недели: их семь, значит, размер по первому измерению — 7, а затем — номер показателя: всего их 2. Вот так:

CREATE TABLE taxi.depots_economic_report(
    id integer PRIMARY KEY,
    depot_id integer,
    date_begin date,
    economic_data integer[7][2]
); 
При этом ни использование двух пар квадратных скобок, ни указание размера по каждому измерению не несут никаких дополнительных преимуществ. Вы также сможете вставить в таблицу, созданную последним скриптом, трёхмерный массив с десятью элементами в каждом измерении.
Вставляем значения массива
Таблицы созданы — пора формировать массивы для вставки строк в таблицу. Есть два варианта синтаксиса при формировании массива:
Фигурные скобки {}.
Конструктор ARRAY.
Разберём их по порядку.
Вставляем значения с помощью {}
Синтаксис такой: одинарные кавычки, внутри них — фигурные скобки, а внутри фигурных скобок через запятую перечисляют элементы. Текстовые элементы заключают в двойные кавычки.

'{элемент1, элемент2, ...}' 
Вставьте строку в таблицу clients:

INSERT INTO taxi.clients(id, client_name, phone, add_phones) 
VALUES (1, 'Лесной Анатолий Игоревич', '71112223344', 
       '{"78885556677", "73335556677"}'); 
Этот синтаксис подходит и для многомерных массивов. Просто вместо элементов указывают вложенные массивы. Например, для двумерного массива это выглядит так:

'{{элемент1 массива1, элемент2 массива1, ...}, 
 {элемент1 массива2, элемент2 массива2}, ...}' 
Добавьте строку в таблицу depots_economic_report. В качестве даты начала недели используйте функцию current_date.

INSERT INTO taxi.depots_economic_report(id, depot_id, date_begin, economic_data) 
VALUES (1, 1, current_date, '{{100, 40}, {200, 85}}'); 
Вы добавили в таблицу данные по таксопарку с id = 1 за два дня. В первый день выручка составила 100 000, а прибыль — 40 000. Во второй день выручка составила 200 000, прибыль — 85 000.
id	depot_id	date_begin	economic_data
1	1	1	2023-08-04	{{100,40},{200,85}}
Вставляя многомерные массивы, нужно следить, чтобы у всех вложенных массивов был одинаковый размер. Например, если вы захотите добавить в первый день только выручку, а для второго дня и выручку, и прибыль:

INSERT INTO taxi.depots_economic_report(id, depot_id, date_begin, economic_data)  
VALUES (2, 7, current_date, '{{100}, {200, 85}}'); 
такой запрос вернёт ошибку:
ERROR:  Multidimensional arrays must have sub-arrays with matching 
        dimensions.malformed array literal: "{{100}, {200, 85}}" 
Вставляем значения с помощью конструктора ARRAY


С помощью ключевого слова ARRAY можно вставлять в таблицу как одномерные, так и многомерные массивы. Элементы одномерных массивов заключают в квадратные скобки и разделяют запятыми. 
Этот скрипт вставит массив в таблицу clients:

INSERT INTO taxi.clients(id, client_name, phone, add_phones) 
VALUES (2, 'Полевой Александр Павлович', '73332221144', 
        ARRAY['78881112233', '77772224477']) 
В многомерном массиве вложенные массивы заключают во вложенные квадратные скобки. 
Вставьте новую строку в depots_economic_report:

INSERT INTO taxi.depots_economic_report(id, depot_id, date_begin, economic_data)  
VALUES (2, 7, current_date, ARRAY[[350, 90], [400, 120]]); 
Нужно создать таблицу array_test, одно из полей которой — массив целых чисел:

CREATE TABLE array_test(
    id integer PRIMARY KEY,
    arr_data <...>
) 
Что можно вставить на место <…>? Выберите все правильные варианты ответа.


integer
У такого поля будет целочисленный тип, но не тип массива.

text[]
У такого поля будет тип массива текстовых данных, но не массива целых чисел.

Правильный ответ
integer[]
Массив можно задать квадратными скобками после указания типа данных. Это один из вариантов объявления массива.

Правильный ответ
integer ARRAY
ARRAY после названия типа данных — вариант объявления массива.

Правильный ответ
integer[][]
Двойные квадратные скобки никак не повлияют на размерность вставляемых значений. Это тоже может быть вариантом объявления массива.

ARRAY[integer]
В квадратных скобках после ключевого слова ARRAY можно указать только размер массива.

Неправильный ответ
ARRAY[3]
Перед ключевым словом ARRAY нужно указать тип данных.
Теперь нужно наполнить таблицу array_test данными:

INSERT INTO array_test(id, arr_data) VALUES (1, <...>) 
Что можно вставить на место <…>? Выберите все правильные варианты ответа.


'{"1", "2"}'
Численные значения не нужно заключать в двойные кавычки, иначе СУБД воспримет их как строковые.

Неправильный ответ
ARRAY{1, 2}
После ключевого слова ARRAY используют квадратные скобки.

Правильный ответ
ARRAY[1, 2]
Такой синтаксис допустим для создания массива.

Неправильный ответ
{{1, 2}, {3, 4}}
Фигурные скобки заключают в одинарные кавычки.

Неправильный ответ
ARRAY[[1, 2], [3, 4, 5]]
В этом двумерном массиве у вложенных массивов разные размеры.

Правильный ответ
'{5, 6}'
Такой синтаксис допустим для создания массива.
Массив создан, данные вставлены, знания закреплены — время чтения.
Читаем данные из массива
Часто нужно получить какой-то конкретный элемент массива по его индексу. Вот как это делается.
Чтобы получить элемент одномерного массива, нужно в квадратных скобках указать его индекс. Помните, что индексация в PostgreSQL начинается с 1. 
Например, найдите первый добавочный телефон у клиента с id = 1:

SELECT add_phones[1] FROM taxi.clients WHERE id = 1; 
Если указать индекс несуществующего элемента, это не приведёт к ошибке, но запрос вернёт NULL:

SELECT add_phones[2] FROM taxi.clients WHERE id = 1;
SELECT add_phones[100] FROM taxi.clients WHERE id = 1; 
Чтобы получить элемент двумерного массива, проще всего представить его как таблицу, состоящую из строк и столбцов. Нужно указать сначала номер строки в квадратных скобках, затем номер столбца в квадратных скобках. 
Вот как найти прибыль (2-й столбец) за понедельник у таксопарка с id = 1:

SELECT economic_data[1][2] FROM taxi.depots_economic_report WHERE depot_id = 1; 
Если размерность вашего массива больше двух, найти конкретный элемент может быть сложнее. 
Рассмотрим трёхмерный массив цифр: {{{1, 2}, {3, 4}}, {{5, 6}, {7, 8}}}.
Для наглядности поместим его в таблицу array_tests:

CREATE TABLE array_tests(
    arr_data integer[]
);

INSERT INTO array_tests(arr_data) 
VALUES ('{{{1, 2}, {3, 4}}, {{5, 6}, {7, 8}}}'); 
Нужно получить элемент со значением 6. Вот как это сделать:
Запишите SELECT и количество пар квадратных скобок, равное размерности массива — то есть трём:

SELECT arr_data[][][] FROM array_tests; 
Начните с самого внешнего массива. Он содержит в себе два вложенных массива:
Значения {{1, 2}, {3, 4}} с индексом 1 — первый массив. Значения {{5, 6}, {7, 8}} с индексом 2 — второй массив
Элемент со значением 6 находится в элементе с индексом 2 — запишите его в первые квадратные скобки:

SELECT arr_data[2][][] FROM array_tests 
Возьмите массив {{5, 6}, {7, 8}} и рассмотрите его:
Значения {5, 6} с индексом 1 — первый одномерный массив. Значения {7, 8} с индексом 2 — второй одномерный массив
Это двумерный массив, состоящий из двух одномерных. В нём индекс нужного вам одномерного массива равен 1. Запишите это число во вторые квадратные скобки:

SELECT arr_data[2][1][] FROM array_tests 
Рассмотрите самый вложенный одномерный массив. Он состоит из двух элементов:
В массиве {5, 6} у элемента 5 индекс 1, у элемента 6 индекс 2
У искомого элемента индекс 2. Это число запишите в последние квадратные скобки:

SELECT arr_data[2][1][2] FROM array_tests 
Выполните скрипт и убедитесь, что получили нужный результат.
В таблицу array_test вставили массив:

INSERT INTO array_test(id, arr_data) VALUES (2, '{{3, 4}, {5, 6}, {7, 8}}') 
Какой результат выдаст такой скрипт? 

SELECT arr_data[2][1] FROM array_test WHERE id = 2 
Выберите единственный верный вариант ответа.


4
Нужно было найти первый элемент второго массива. 4 — это второй элемент первого массива.

Правильный ответ
5
Нашёлся! Это первый элемент второго массива.

8
Это второй элемент третьего массива, а нужен первый элемент второго.

7
Это первый элемент третьего, а не второго массива. Индексы массивов нумеруются с 1.
В таблицу array_test вставили массив:

INSERT INTO array_test(id, arr_data)
VALUES (2, '{{{3, 4}, {5, 6}, {7, 8}}, {{9, 0}, {1, 2}, {10, 11}}}') 
Какой результат выдаст такой скрипт?

SELECT arr_data[1][2][2] FROM array_test WHERE id = 2 
Выберите единственный верный вариант ответа.


Правильный ответ
6
Нужно было найти первый двумерный массив, затем второй одномерный массив внутри и в нём второй элемент. Это будет 6.

11
Это элемент arr_data [2] [3] [2], а ищем мы кое-что другое.

2
Ищем в обратном порядке: это второй элемент из второго одномерного массива, который находится во втором двумерном массиве.

8
Элемент 8 находится в третьем одномерном массиве внутри первого двумерного.

