Запросы с транзакциями
В прошлых уроках вы познакомились с транзакциями и их ключевыми особенностями, а в этом уроке узнаете, как работать с транзакциями.
В PostgreSQL транзакция начинается с команды BEGIN ; и заканчивается командой COMMIT ;. Весь код SQL между этими командами считается одной транзакцией. Также его называют блоком транзакции.
Иллюстрация текста выше
Изменения, сделанные в транзакции, но ещё не зафиксированные командой COMMIT, называют незафиксированными изменениями. Если вы захотите отменить эти изменения, выполните команду ROLLBACK — она откатит состояние базы данных к тому, что было до начала транзакции. 
Есть ряд ситуаций, при которых до момента выполнения команды COMMIT, все незафиксированные изменения становятся недоступными. Например, если в одном из запросов транзакции возникнет ошибка или произойдёт сбой в работе БД.
Команду COMMIT используют для того, чтобы закрепить в БД изменения, внесённые текущей транзакцией. Транзакцию, изменения которой были зафиксированы командой COMMIT, называют подтверждённой или зафиксированной.
Запросы без явного указания транзакции, такие, как вы делали во всех предыдущих уроках, выполняются как отдельная транзакция с автоматической фиксацией (англ. autocommit).
Вернёмся к задаче с переводом денег с одного счёта на другой. 
Есть две таблицы: accounts с информацией о балансах на счетах и account_transactions со всеми операциями по счетам. Описание таблиц и скрипты их создания вы разбирали в первом уроке темы.
Также в первом уроке вы рассмотрели четыре SQL-запроса, которые переводят средства с одного счёта на другой, и выяснили, что необходимо создать одну неделимую транзакцию для выполнения этих запросов. 
Вот как это будет выглядеть в формате единой транзакции:

BEGIN;  -- открываем транзакцию
    UPDATE bank.accounts
    SET balance = balance - 500,
        last_update = CURRENT_TIMESTAMP
    WHERE account_number = 'BG22UBBS890';
    
    UPDATE bank.accounts
    SET balance = balance + 500,
        last_update = CURRENT_TIMESTAMP
    WHERE account_number = 'BG31UBBS012';

    INSERT INTO bank.account_transactions 
        (account_id, transaction_amount, transaction_type)
    VALUES 
        (1, 500, 'W');

    INSERT INTO bank.account_transactions 
        (account_id, transaction_amount, transaction_type)
    VALUES
        (3, 500, 'D');
COMMIT;  -- завершаем транзакцию 
Можно запустить весь код целиком или каждую команду последовательно.
После выполнения запроса балансы счетов изменились, а в списке операций появились две новые строки.
accounts:
id	account_number	balance	last_update
1	BG22UBBS890	4500.00	2023-06-01 10:00:05
3	BG31UBBS012	15500.00	2023-06-01 10:00:05
2	BG79UBBS901	3000.00	2023-05-21 00:00:00
account_transactions:
id	account_id	transaction_amount	transaction_type	created_at
1	1	1000.00	D	2023-05-30 00:00:00
2	1	500.00	W	2023-05-29 00:00:00
3	2	1500.00	D	2023-05-31 00:00:00
4	3	5000.00	W	2023-05-30 00:00:00
5	1	500.00	W	2023-06-01 10:00:05
6	3	500.00	D	2023-06-01 10:00:05
Теперь разберём, что случится, если один из запросов не сработает. Ситуацию с падением сервера воспроизвести сложно, но можно изменить один из запросов так, чтобы он стал некорректным. 
Например, в запросе № 3 исправьте значение для столбца account_id и укажите такой account_id, которого нет в таблице со счетами:

INSERT INTO bank.account_transactions 
    (account_id, transaction_amount, transaction_type)
VALUES 
    (8, 500, 'W'); 
Снова откройте транзакцию и запустите все запросы, но поочерёдно, так как DBeaver не перейдёт к следующему запросу, если предыдущий завершился ошибкой. 
Перед тем как выполнить запрос № 3, сделайте SELECT из таблицы accounts, чтобы посмотреть, какие изменения уже внесены. Вы увидите, что баланс счетов поменялся:
id	account_number	balance	last_update
1	BG22UBBS890	4000.00	2023-06-01 10:10:34
3	BG31UBBS012	16000.00	2023-06-01 10:10:34
2	BG79UBBS901	3000.00	2023-05-21 00:00:00
Теперь выполните запрос № 3. Результатом станет ошибка: 
ERROR: Key (account_id)=(8) is not present in table "accounts".
       Insert or update on table "account_transactions" violates foreign key 
       constraint "account_transactions_account_id_fkey"

Ошибка говорит, что ключа account_id = 8 нет в таблице accounts, и вставка данных или обновление таблицы account_transactions нарушает ограничение внешнего ключа account_transactions_account_id_fkey.
Транзакция прервалась ошибкой, и теперь нужно отменить все изменения в данных, которые были внесены этой транзакцией, так как для решения задачи должны выполниться либо все четыре запроса, либо ни один.
Чтобы полностью отменить транзакцию и вернуться к состоянию, которое было до старта транзакции — до BEGIN, используйте оператор ROLLBACK. Откатите транзакцию:



ROLLBACK; 
и проверьте, что баланс на счетах в таблице accounts вернулся к значениям, которые были до старта транзакции:
id	account_number	balance	last_update
1	BG22UBBS890	4500.00	2023-06-01 10:00:05
3	BG31UBBS012	15500.00	2023-06-01 10:00:05
2	BG79UBBS901	3000.00	2023-05-21 00:00:00
ROLLBACK можно использовать в любой момент, когда вы передумали фиксировать транзакцию и хотите отменить все внесённые изменения. 
При этом если в текущей транзакции произошла ошибка и выполнение транзакции уже прервано, то при попытке выполнить какой-либо другой запрос PostgreSQL выдаст такое сообщение:
ERROR:  current transaction is aborted, commands ignored until 
        end of transaction block
ОШИБКА: текущая транзакция прервана, команды до конца блока транзакции 
        игнорируются

SQL state: 25P02 
Это сообщение об ошибке означает, что несмотря на то, что выполнение транзакции уже было прервано, PostgreSQL всё равно ждёт ROLLBACK. То есть СУБД не может самостоятельно закрыть явно открытую транзакцию в случае ошибки, поэтому выполнить ROLLBACK — обязательно. Только после этого можно будет выполнять любые другие запросы к БД.
Точки сохранения транзакции
Также транзакции можно откатить не полностью, а к некоторой сохранённой точке внутри транзакции. Для создания такой точки используют конструкцию 
SAVEPOINT имя_точки_сохранения.
Команда ROLLBACK. Чтобы откатить транзакцию к точке сохранения, то есть отменить запросы, которые были выполнены после неё, применяют команду ROLLBACK TO [SAVEPOINT] имя_точки_сохранения. При этом, если после ROLLBACK TO в транзакции есть ещё запросы, они продолжат выполняться.
Код транзакции. Между `SAVEPOINT` и `ROLLBACK TO [SAVEPOINT]` есть два запроса, команда  `ROLLBACK TO [SAVEPOINT]` их отменит. После команды `ROLLBACK TO [SAVEPOINT]` есть ещё два запроса — они продолжат выполняться
Если во время выполнения скрипта произойдёт ошибка, все дальнейшие запросы можно выполнить только вручную — автоматически они не выполнятся.
Команда ROLLBACK без указания точки сохранения отменит всю транзакцию целиком.
Команда RELEASE. Чтобы удалить точку сохранения, применяют команду RELEASE [SAVEPOINT] имя_точки_сохранения.  На изменения, совершённые внутри транзакции, это не повлияет.
В PostgreSQL ключевое слово SAVEPOINT в командах ROLLBACK и RELEASE можно не использовать. Поэтому, чтобы обозначить его необязательность, заключают в квадратные скобки — как и в документации.
В транзакции можно создать несколько точек. Назвать точки можно одним именем или разными. Если назвать одним именем несколько SAVEPOINT, использоваться будет только та точка, которая была объявлена последней — при откате транзакции и удалении точки сохранения. Если эту точку удалить, далее в транзакции будет использоваться точка с таким же именем, которая была объявлена до удалённой. И так далее, если таких точек несколько.
Если в рамках одной транзакции установлено несколько точек сохранения и применяется команда ROLLBACK TO для отката к одной из этих точек, то все запросы, выполненные после этой точки сохранения, отменятся. Более того, все точки сохранения, установленные после той, к которой откатывается транзакция, также удалятся. Логично — ведь все запросы после SAVEPOINT, в том числе и на создание других SAVEPOINT, удаляются. 
Удалять точки сохранения необязательно, но это позволяет системе освобождать некоторые ресурсы раньше, чем завершится транзакция.
Какие запросы UPDATE выполнятся в такой транзакции? Выберите единственный верный ответ.

BEGIN;
    UPDATE ...;   -- запрос 1
    SAVEPOINT test_point;
    UPDATE ...;   -- запрос 2
    SAVEPOINT test_point;  
    UPDATE ...;   -- запрос 3
  ROLLBACK TO SAVEPOINT test_point;
    UPDATE ...;   -- запрос 4
  RELEASE SAVEPOINT test_point;
  ROLLBACK TO SAVEPOINT test_point;
    UPDATE ...;   -- запрос 5
COMMIT; 


1, 2 и 5.
Запрос 2 отменится вторым ROLLBACK TO, так как перед ним есть RELEASE SAVEPOINT, который удаляет вторую точку сохранения, и отмена идёт до запроса 1.

1, 2, 3 и 5.
Запрос 3 отменится первым ROLLBACK TO , так как точка сохранения установлена до него. Запрос2 отменяться вторым ROLLBACK TO, так как перед ним есть RELEASE SAVEPOINT, который удаляет вторую точку сохранения, и отмена идёт до запроса 1.

1, 4 и 5.
Запрос 4 отменится вторым ROLLBACK TO, так как перед ним есть RELEASE SAVEPOINT, который удаляет вторую точку сохранения, и отмена идёт до запроса 1.

Правильный ответ
1 и 5.
RELEASE SAVEPOINT удаляет вторую точку сохранения, и следующий за ним ROLLBACK TO отменит все запросы, которые были выполнены, — кроме запроса 1. После запроса 5 отмен нет, он будет исполнен.
Каким будет результат такой транзакции? Выберите единственный верный ответ.

BEGIN;
    UPDATE ...;   -- запрос 1
    SAVEPOINT point1;
    UPDATE ...;   -- запрос 2
    SAVEPOINT point2;  
    UPDATE ...;   -- запрос 3
    SAVEPOINT point3; 
    UPDATE ...;   -- запрос 4
  ROLLBACK TO SAVEPOINT point2;
    UPDATE ...;   -- запрос 5
    RELEASE SAVEPOINT point3;
    UPDATE ...;   -- запрос 6
COMMIT; 


Неправильный ответ
1, 2, 5 и 6.
Ни один запрос не выполнится, так как в транзакции есть ошибка.

1, 2, 4, 5 и 6.
Запрос 4 не может выполниться из-за ROLLBACK TO, который идёт после него. Остальные запросы также не смогут быть выполнены, так как в транзакции есть ошибка.

1, 2 и 6.
Ни один запрос не выполнится, так как в транзакции есть ошибка.

Тоже правильный ответ
Ошибка выполнения транзакции — ERROR: savepoint "point3" does not exist.
ROLLBACK TO отменит запросы, которые были выполнены после point2, но также удалит все запросы, созданные после точки сохранения. Поэтому попытка удалить point3 вызовет ошибку, так как этой точки уже нет.
Сопоставьте ситуации и операторы, необходимые для их решения.
Нужно выполнить несколько операций в базе данных: занести новый заказ в таблицу оrders с заказами и изменить наличие в таблице stock с остатком товаров на складе. Важно избежать непредсказуемых результатов и сохранить целостность данных.
BEGIN; COMMIT;
Чтобы сохранить целостность данных и избежать непредсказуемых результатов, нужно выполнять код в отдельной транзакции.
При добавлении нового заказа в таблицу оrders и уменьшении количества товара на складе в таблице stock произошла ошибка. Запрос не выполнился, так как таблица stock поддерживает только положительный остаток, а заказ по ошибке был оформлен на большее количество товара.
BEGIN; ROLLBACK;
Так как произошла ошибка, придётся откатить транзакцию.
Добавление новых пользователей в таблицу users.
INSERT
Чтобы добавить строки в одну таблицу, создавать отдельную транзакцию не нужно.

